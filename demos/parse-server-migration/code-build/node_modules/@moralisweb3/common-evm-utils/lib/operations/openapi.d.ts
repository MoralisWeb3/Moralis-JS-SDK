/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */
export interface paths {
    "/{address}/nft": {
        /**
         * Get NFTs owned by a given address.
         * * The response will include status [SYNCED/SYNCING] based on the contracts being indexed.
         * * Use the token_address param to get results for a specific contract only
         * * Note that results will include all indexed NFTs
         * * Any request that includes the token_address param will start the indexing process for that NFT collection the very first time it is requested.
         */
        get: operations["getWalletNFTs"];
    };
    "/{address}/nft/transfers": {
        /** Get transfers of NFTs given the wallet and other parameters. */
        get: operations["getWalletNFTTransfers"];
    };
    "/{address}/nft/collections": {
        /** Get NFT collections owned by a given wallet address. */
        get: operations["getWalletNFTCollections"];
    };
    "/nft/{address}": {
        /**
         * Get NFTs for a given contract address, including metadata for all NFTs (where available).
         * * Results are limited to 100 per page by default
         * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection.
         */
        get: operations["getContractNFTs"];
    };
    "/nft/{address}/owners": {
        /**
         * Get owners of NFTs for a given contract.
         * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection.
         */
        get: operations["getNFTOwners"];
    };
    "/nft/{address}/transfers": {
        /** Get transfers of NFTs for a given contract and other parameters. */
        get: operations["getNFTContractTransfers"];
    };
    "/nft/transfers": {
        /** Get transfers of NFTs from a block number to a block number. */
        get: operations["getNFTTransfersFromToBlock"];
    };
    "/block/{block_number_or_hash}/nft/transfers": {
        /** Get transfers of NFTs given a block number or block hash. */
        get: operations["getNFTTransfersByBlock"];
    };
    "/nft/{address}/trades": {
        /** Get trades of NFTs for a given contract and marketplace. */
        get: operations["getNFTTrades"];
    };
    "/nft/{address}/metadata": {
        /**
         * Get the collection / contract level metadata for a given contract (name, symbol, base token URI).
         * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
         */
        get: operations["getNFTContractMetadata"];
    };
    "/nft/{address}/{token_id}": {
        /**
         * Get NFT data, including metadata (where available), for the given NFT token ID and contract address.
         * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
         */
        get: operations["getNFTMetadata"];
    };
    "/nft/{address}/{token_id}/transfers": {
        /** Get transfers of an NFT given a contract address and token ID. */
        get: operations["getNFTTransfers"];
    };
    "/nft/{address}/{token_id}/owners": {
        /**
         * Get owners of a specific NFT given the contract address and token ID.
         * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
         */
        get: operations["getNFTTokenIdOwners"];
    };
    "/nft/{address}/sync": {
        /** Initiates a sync of a previously non synced contract. */
        put: operations["syncNFTContract"];
    };
    "/nft/{address}/{token_id}/metadata/resync": {
        /**
         * Resync the metadata for an NFT
         * * The metadata flag will request the NFT's metadata from an already existing token_uri
         * * The URI (default) flag will fetch the latest token_uri from the given NFT contract address. In sync mode the metadata will also be fetched
         * * The sync mode will make the endpoint synchronous so it will wait for the task to be completed before responding
         * * The async mode (default) will make the endpoint asynchronous so we will wait for the task to be completed before responding
         */
        get: operations["reSyncMetadata"];
    };
    "/nft/{address}/lowestprice": {
        /** Get the lowest executed price for an NFT contract for the last x days (only trades paid in ETH). */
        get: operations["getNFTLowestPrice"];
    };
    "/nft/search": {
        /** Get NFTs that match a given metadata search query. */
        get: operations["searchNFTs"];
    };
    "/erc20/{address}/price": {
        /** Get the token price denominated in the blockchain's native token and USD. */
        get: operations["getTokenPrice"];
    };
    "/{address}/erc20": {
        /** Get token balances for a specific wallet address. */
        get: operations["getWalletTokenBalances"];
    };
    "/{address}/erc20/transfers": {
        /** Get ERC20 token transactions ordered by block number in descending order. */
        get: operations["getWalletTokenTransfers"];
    };
    "/erc20/metadata": {
        /** Get the metadata for a given token contract address (name, symbol, decimals, logo). */
        get: operations["getTokenMetadata"];
    };
    "/erc20/metadata/symbols": {
        /** Get the metadata for a list of token symbols (name, symbol, decimals, logo). */
        get: operations["getTokenMetadataBySymbol"];
    };
    "/erc20/{address}/allowance": {
        /** Get the amount which the spender is allowed to withdraw on behalf of the owner. */
        get: operations["getTokenAllowance"];
    };
    "/erc20/{address}/transfers": {
        /** Get ERC20 token transactions from a contract ordered by block number in descending order. */
        get: operations["getTokenTransfers"];
    };
    "/{address}/balance": {
        /** Get the native balance for a specific wallet address. */
        get: operations["getNativeBalance"];
    };
    "/{address}": {
        /** Get native transactions ordered by block number in descending order. */
        get: operations["getWalletTransactions"];
    };
    "/transaction/{transaction_hash}": {
        /** Get the contents of a transaction by the given transaction hash. */
        get: operations["getTransaction"];
    };
    "/block/{block_number_or_hash}": {
        /** Get the contents of a block given the block hash. */
        get: operations["getBlock"];
    };
    "/dateToBlock": {
        /** Get the closest block given the date. */
        get: operations["getDateToBlock"];
    };
    "/{address}/logs": {
        /** Get the logs for a contract. */
        get: operations["getContractLogs"];
    };
    "/{address}/events": {
        /** Get events for a contract ordered by block number in descending order. */
        post: operations["getContractEvents"];
    };
    "/{address}/function": {
        /** Run a given function of a contract ABI and retrieve readonly data. */
        post: operations["runContractFunction"];
    };
    "/web3/version": {
        /** Get the current version of the Moralis Web3 API. */
        get: operations["web3ApiVersion"];
    };
    "/info/endpointWeights": {
        /** Get the cost and rate limit for each API endpoint. */
        get: operations["endpointWeights"];
    };
    "/resolve/{address}/reverse": {
        /** Resolve an ETH address and find the ENS name. */
        get: operations["resolveAddress"];
    };
    "/resolve/{domain}": {
        /** Resolve an Unstoppable domain and get the address. */
        get: operations["resolveDomain"];
    };
    "/{pair_address}/reserves": {
        /** Get the liquidity reserves for a given pair address. Only Uniswap V2 based exchanges supported at the moment. */
        get: operations["getPairReserves"];
    };
    "/{token0_address}/{token1_address}/pairAddress": {
        /**
         * Fetch the pair data of the provided token0+token1 combination.
         * The token0 and token1 options are interchangable (ie. there is no different outcome in "token0=WETH and token1=USDT" or "token0=USDT and token1=WETH")
         */
        get: operations["getPairAddress"];
    };
    "/ipfs/uploadFolder": {
        /** Upload multiple files to IPFS and place them in a folder directory. */
        post: operations["uploadFolder"];
    };
}
export interface components {
    schemas: {
        logCollection: {
            /**
             * @description The total number of matches for this query
             * @example 100
             */
            total?: number;
            /**
             * @description The current page of the result
             * @example 1
             */
            page?: number;
            /**
             * @description The number of results per page
             * @example 100
             */
            page_size?: number;
            /** @description The cursor to get to the next page */
            cursor?: string;
            result?: components["schemas"]["logEventByAddress"][];
        };
        logEventByAddress: {
            /**
             * @description The transaction hash
             * @example 0x2d30ca6f024dbc1307ac8a1a44ca27de6f797ec22ef20627a1307243b0ab7d09
             */
            transaction_hash: string;
            /**
             * @description The address of the contract
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            address: string;
            /**
             * @description The block timestamp
             * @example 2021-04-02T10:07:54.000Z
             */
            block_timestamp: string;
            /**
             * @description The block number
             * @example 12526958
             */
            block_number: string;
            /**
             * @description The block hash
             * @example 0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86
             */
            block_hash: string;
            /**
             * @description The data of the log
             * @example 0x00000000000000000000000000000000000000000000000de05239bccd4d537400000000000000000000000000024dbc80a9f80e3d5fc0a0ee30e2693781a443
             */
            data: string;
            /** @example 0x2caecd17d02f56fa897705dcc740da2d237c373f70686f4e0d9bd3bf0400ea7a */
            topic0: string;
            /** @example 0x000000000000000000000000031002d15b0d0cd7c9129d6f644446368deae391 */
            topic1: string;
            /** @example 0x000000000000000000000000d25943be09f968ba740e0782a34e710100defae9 */
            topic2: string;
            /** @example null */
            topic3: string;
            /**
             * @description The Transaction index of the log within the block
             * @example 12
             */
            transaction_index: number;
            /**
             * @description The log index of the log within the block
             * @example 15
             */
            log_index: number;
        };
        logEvent: {
            /**
             * @description The transaction hash
             * @example 0x2d30ca6f024dbc1307ac8a1a44ca27de6f797ec22ef20627a1307243b0ab7d09
             */
            transaction_hash: string;
            /**
             * @description The address of the contract
             * @example 0x18F97EF6B2cbac5CA85b375b7093C4A207340d06
             */
            address: string;
            /**
             * @description The block timestamp
             * @example 2021-04-02T10:07:54.000Z
             */
            block_timestamp: string;
            /**
             * @description The block number
             * @example 12526958
             */
            block_number: string;
            /**
             * @description The block hash
             * @example 0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86
             */
            block_hash: string;
            /** @description The content of the event */
            data: {
                /** @example 0x54ff6974c715956a5049a123408bff91fbe29f01 */
                from?: string;
                /** @example 0x74de5d4fcbf63e00296fd95d33236b9794016631 */
                to?: string;
                /** @example 260103496340000000000 */
                value?: string;
            };
        };
        log: {
            /** @example 273 */
            log_index: string;
            /**
             * @description The hash of the transaction
             * @example 0xdd9006489e46670e0e85d1fb88823099e7f596b08aeaac023e9da0851f26fdd5
             */
            transaction_hash: string;
            /** @example 204 */
            transaction_index: string;
            /**
             * @description The address of the contract
             * @example 0x3105d328c66d8d55092358cf595d54608178e9b5
             */
            address: string;
            /**
             * @description The data of the log
             * @example 0x00000000000000000000000000000000000000000000000de05239bccd4d537400000000000000000000000000024dbc80a9f80e3d5fc0a0ee30e2693781a443
             */
            data: string;
            /** @example 0x2caecd17d02f56fa897705dcc740da2d237c373f70686f4e0d9bd3bf0400ea7a */
            topic0: string;
            /** @example 0x000000000000000000000000031002d15b0d0cd7c9129d6f644446368deae391 */
            topic1?: string | unknown;
            /** @example 0x000000000000000000000000d25943be09f968ba740e0782a34e710100defae9 */
            topic2?: string | unknown;
            /** @example null */
            topic3?: string | unknown;
            /**
             * @description The timestamp of the block
             * @example 2021-05-07T11:08:35.000Z
             */
            block_timestamp: string;
            /**
             * @description The block number
             * @example 12386788
             */
            block_number: string;
            /**
             * @description The hash of the block
             * @example 0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171
             */
            block_hash: string;
        };
        blockTransaction: {
            /**
             * @description The hash of the transaction
             * @example 0x1ed85b3757a6d31d01a4d6677fc52fd3911d649a0af21fe5ca3f886b153773ed
             */
            hash: string;
            /**
             * @description The nonce
             * @example 1848059
             */
            nonce: string;
            /** @example 108 */
            transaction_index: string;
            /**
             * @description The from address
             * @example 0x267be1c1d684f78cb4f6a176c4911b741e4ffdc0
             */
            from_address: string;
            /**
             * @description The to address
             * @example 0x003dde3494f30d861d063232c6a8c04394b686ff
             */
            to_address: string | unknown;
            /**
             * @description The value sent
             * @example 115580000000000000
             */
            value: string;
            /** @example 30000 */
            gas?: string;
            /**
             * @description The gas price
             * @example 52500000000
             */
            gas_price: string;
            /** @example 0x */
            input: string;
            /** @example 4923073 */
            receipt_cumulative_gas_used: string;
            /** @example 21000 */
            receipt_gas_used: string;
            /** @example null */
            receipt_contract_address?: string | unknown;
            /** @example null */
            receipt_root?: string | unknown;
            /** @example 1 */
            receipt_status: string;
            /**
             * @description The block timestamp
             * @example 2021-05-07T11:08:35.000Z
             */
            block_timestamp: string;
            /**
             * @description The block number
             * @example 12386788
             */
            block_number: string;
            /**
             * @description The hash of the block
             * @example 0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171
             */
            block_hash: string;
            /** @description The logs of the transaction */
            logs?: components["schemas"]["log"][];
        };
        block: {
            /**
             * @description The block timestamp
             * @example 2021-05-07T11:08:35.000Z
             */
            timestamp: string;
            /**
             * @description The block number
             * @example 12386788
             */
            number: string;
            /**
             * @description The block hash
             * @example 0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171
             */
            hash: string;
            /**
             * @description The block hash of the parent block
             * @example 0x011d1fc45839de975cc55d758943f9f1d204f80a90eb631f3bf064b80d53e045
             */
            parent_hash: string;
            /**
             * @description The nonce
             * @example 0xedeb2d8fd2b2bdec
             */
            nonce: string;
            /** @example 0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347 */
            sha3_uncles: string;
            /** @example 0xdde5fc46c5d8bcbd58207bc9f267bf43298e23791a326ff02661e99790da9996b3e0dd912c0b8202d389d282c56e4d11eb2dec4898a32b6b165f1f4cae6aa0079498eab50293f3b8defbf6af11bb75f0408a563ddfc26a3323d1ff5f9849e95d5f034d88a757ddea032c75c00708c9ff34d2207f997cc7d93fd1fa160a6bfaf62a54e31f9fe67ab95752106ba9d185bfdc9b6dc3e17427f844ee74e5c09b17b83ad6e8fc7360f5c7c3e4e1939e77a6374bee57d1fa6b2322b11ad56ad0398302de9b26d6fbfe414aa416bff141fad9d4af6aea19322e47595e342cd377403f417dfd396ab5f151095a5535f51cbc34a40ce9648927b7d1d72ab9daf253e31daf */
            logs_bloom: string;
            /** @example 0xe4c7bf3aff7ad07f9e80d57f7189f0252592fee6321c2a9bd9b09b6ce0690d27 */
            transactions_root: string;
            /** @example 0x49e3bfe7b618e27fde8fa08884803a8458b502c6534af69873a3cc926a7c724b */
            state_root: string;
            /** @example 0x7cf43d7e837284f036cf92c56973f5e27bdd253ca46168fa195a6b07fa719f23 */
            receipts_root: string;
            /**
             * @description The address of the miner
             * @example 0xea674fdde714fd979de3edf0f56aa9716b898ec8
             */
            miner: string;
            /**
             * @description The difficulty of the block
             * @example 7253857437305950
             */
            difficulty: string;
            /**
             * @description The total difficulty
             * @example 24325637817906576196890
             */
            total_difficulty: string;
            /**
             * @description The block size
             * @example 61271
             */
            size: string;
            /** @example 0x65746865726d696e652d6575726f70652d7765737433 */
            extra_data: string;
            /**
             * @description The gas limit
             * @example 14977947
             */
            gas_limit: string;
            /**
             * @description The gas used
             * @example 14964688
             */
            gas_used: string;
            /**
             * @description The number of transactions in the block
             * @example 252
             */
            transaction_count: string;
            /** @description The transactions in the block */
            transactions: components["schemas"]["blockTransaction"][];
        };
        blockDate: {
            /**
             * @description The date of the block
             * @example 2020-01-01T00:00:00+00:00
             */
            date: string;
            /**
             * @description The block number
             * @example 9193266
             */
            block: number;
            /**
             * @description The timestamp of the block
             * @example 1577836811
             */
            timestamp: number;
        };
        RunContractDto: {
            /**
             * @description The contract ABI
             * @example []
             */
            abi: {
                [key: string]: unknown;
            };
            /**
             * @description The params for the given function
             * @example {}
             */
            params?: {
                [key: string]: unknown;
            };
        };
        transactionCollection: {
            /**
             * @description The total number of matches for this query
             * @example 2000
             */
            total?: number;
            /**
             * @description The current page of the result
             * @example 2
             */
            page?: number;
            /**
             * @description The number of results per page
             * @example 100
             */
            page_size?: number;
            result?: components["schemas"]["transaction"][];
        };
        transaction: {
            /**
             * @description The hash of the transaction
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            hash: string;
            /**
             * @description The nonce of the transaction
             * @example 326595425
             */
            nonce: string;
            /**
             * @description The transaction index
             * @example 25
             */
            transaction_index: string;
            /**
             * @description The sender
             * @example 0xd4a3BebD824189481FC45363602b83C9c7e9cbDf
             */
            from_address: string;
            /**
             * @description The recipient
             * @example 0xa71db868318f0a0bae9411347cd4a6fa23d8d4ef
             */
            to_address: string;
            /**
             * @description The value that was transferred (in wei)
             * @example 650000000000000000
             */
            value: string;
            /**
             * @description The gas of the transaction
             * @example 6721975
             */
            gas: string;
            /**
             * @description The gas price
             * @example 20000000000
             */
            gas_price: string;
            /** @description The input */
            input: string;
            /**
             * @description The receipt cumulative gas used
             * @example 1340925
             */
            receipt_cumulative_gas_used: string;
            /**
             * @description The receipt gas used
             * @example 1340925
             */
            receipt_gas_used: string;
            /**
             * @description The receipt contract address
             * @example 0x1d6a4cf64b52f6c73f201839aded7379ce58059c
             */
            receipt_contract_address: string;
            /** @description The receipt root */
            receipt_root: string;
            /**
             * @description The receipt status
             * @example 1
             */
            receipt_status: string;
            /**
             * @description The block timestamp
             * @example 2021-04-02T10:07:54.000Z
             */
            block_timestamp: string;
            /**
             * @description The block number
             * @example 12526958
             */
            block_number: string;
            /**
             * @description The block hash
             * @example 0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86
             */
            block_hash: string;
        };
        erc20Allowance: {
            /** @description The allowance */
            allowance: string;
        };
        erc20TokenBalance: {
            /**
             * @description The address of the token contract
             * @example 0x2d30ca6f024dbc1307ac8a1a44ca27de6f797ec22ef20627a1307243b0ab7d09
             */
            token_address: string;
            /**
             * @description The name of the token contract
             * @example Kylin Network
             */
            name: string;
            /**
             * @description The symbol of the NFT contract
             * @example KYL
             */
            symbol: string;
            /**
             * @description The logo of the token
             * @example https://cdn.moralis.io/eth/0x67b6d479c7bb412c54e03dca8e1bc6740ce6b99c.png
             */
            logo?: string;
            /**
             * @description The thumbnail of the logo
             * @example https://cdn.moralis.io/eth/0x67b6d479c7bb412c54e03dca8e1bc6740ce6b99c_thumb.png
             */
            thumbnail?: string;
            /**
             * @description The number of decimals on the token
             * @example 18
             */
            decimals: number;
            /**
             * @description Timestamp of when the contract was last synced with the node
             * @example 123456789
             */
            balance: string;
        };
        nativeBalance: {
            /**
             * @description The balance
             * @example 1234567890
             */
            balance: string;
        };
        trade: {
            /**
             * @description The transaction hash
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            transaction_hash: string;
            /** @description The transaction index */
            transaction_index: string;
            /**
             * @description The token ID(s) traded
             * @example [
             *   "15",
             *   "54"
             * ]
             */
            token_ids: string[];
            /**
             * @description The address that sold the NFT
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            seller_address: string;
            /**
             * @description The address that bought the NFT
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            buyer_address: string;
            /**
             * @description The address of the contract that traded the NFT
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            marketplace_address: string;
            /**
             * @description The value that was sent in the transaction (ETH/BNB/etc..)
             * @example 1000000000000000
             */
            price: string;
            /**
             * @description The block timestamp
             * @example 2021-06-04T16:00:15
             */
            block_timestamp: string;
            /**
             * @description The block number of the transaction
             * @example 13680123
             */
            block_number: string;
            /**
             * @description The block hash
             * @example 0x4a7c916ca4a970358b9df90051008f729685ff05e9724a9dddba32630c37cb96
             */
            block_hash: string;
        } & {
            token_address: unknown;
        };
        tradeCollection: {
            /**
             * @description The total number of matches for this query
             * @example 2000
             */
            total?: number;
            /**
             * @description The current page of the result
             * @example 2
             */
            page?: number;
            /**
             * @description The number of results per page
             * @example 100
             */
            page_size?: number;
            result?: components["schemas"]["trade"][];
        };
        /**
         * @default eth
         * @example eth
         * @enum {string}
         */
        chainList: "eth" | "0x1" | "goerli" | "0x5" | "sepolia" | "0xaa36a7" | "polygon" | "0x89" | "mumbai" | "0x13881" | "bsc" | "0x38" | "bsc testnet" | "0x61" | "avalanche" | "0xa86a" | "avalanche testnet" | "0xa869" | "fantom" | "0xfa" | "cronos" | "0x19" | "cronos testnet" | "0x152";
        nft: {
            /**
             * @description The address of the NFT contract
             * @example 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB
             */
            token_address: string;
            /**
             * @description The token ID of the NFT
             * @example 15
             */
            token_id: string;
            /**
             * @description The wallet address of the owner of the NFT
             * @example 0x9c83ff0f1c8924da96cb2fcb7e093f78eb2e316b
             */
            owner_of?: string;
            /**
             * @description The token hash
             * @example 502cee781b0fb40ea02508b21d319ced
             */
            token_hash?: string;
            /**
             * @description The block number when the amount or owner changed
             * @example 88256
             */
            block_number?: string;
            /**
             * @description The block number when the NFT was minted
             * @example 88256
             */
            block_number_minted?: string;
            /**
             * @description The type of NFT contract standard
             * @example ERC721
             */
            contract_type: string;
            /** @description The URI to the metadata of the token */
            token_uri?: string;
            /** @description The metadata of the token */
            metadata?: string;
            /** @description A normalized metadata version of the NFT's metadata. */
            normalized_metadata?: components["schemas"]["normalizedMetadata"];
            /**
             * @description The address that minted the NFT
             * @example 0x9c83ff0f1c8924da96cb2fcb7e093f78eb2e316b
             */
            minter_address?: string;
            /** @description When the token_uri was last updated */
            last_token_uri_sync?: string;
            /** @description When the metadata was last updated */
            last_metadata_sync?: string;
            /**
             * @description The quantity of this item that the user owns (used by ERC1155)
             * @example 1
             */
            amount?: string;
            /**
             * @description The name of the NFT contract
             * @example CryptoKitties
             */
            name: string;
            /**
             * @description The symbol of the NFT contract
             * @example RARI
             */
            symbol: string;
        };
        nftMetadata: {
            /**
             * @description The token ID of the NFT
             * @example 889
             */
            token_id: string;
            /**
             * @description The address of the NFT contract
             * @example 0x8ce66ff0865570d1ff0bb0098fa41b4dc61e02e6
             */
            token_address: string;
            /**
             * @description The URI to the metadata of the token
             * @example https://ipfs.moralis.io:2053/ipfs/QmZZbo8u8zEWg7wtmZhJS2W718WL6FA95T4XdgmCcLp1SJ/889.json
             */
            token_uri: string;
            /**
             * @description The metadata of the token
             * @example {"name":"Bape #889","description":"The #1 metavestor clan (NFT/DAO) by a team with multi billion dollar company experience.","image":"https://bapesclan.mypinata.cloud/ipfs/QmTSUD5JA6qHaC5t25mcXySfz19AV9u4Mb6Na7ntQ6tEwf/889.jpg","attributes":[{"trait_type":"Background","value":"Black"},{"trait_type":"Body","value":"Man"},{"trait_type":"Dress","value":"Suit Tie Blue"},{"trait_type":"Face","value":"Pipe"},{"trait_type":"Eye","value":"Eye"}]}
             */
            metadata: string;
            /** @example 1 */
            is_valid: number;
            /** @example 2 */
            syncing: number;
            /** @example 0 */
            frozen: number;
            /** @example 0 */
            resyncing: number;
            /**
             * @description The type of NFT contract standard
             * @example ERC721
             */
            contract_type: string;
            /** @example fffa3102469ce77f569893d16d5884f9 */
            token_hash: string;
            /** @example fd995c8a-f8b2-40cb-a407-f43e552638b4 */
            batch_id: string;
            /** @example Bape #889 */
            metadata_name: string;
            /** @example The #1 metavestor clan (NFT/DAO) by a team with multi billion dollar company experience. */
            metadata_description: string;
            /** @example [{"trait_type":"Background","value":"Black"},{"trait_type":"Body","value":"Man"},{"trait_type":"Dress","value":"Suit Tie Blue"},{"trait_type":"Face","value":"Pipe"},{"trait_type":"Eye","value":"Eye"}] */
            metadata_attributes: string;
            /** @example 14265936 */
            block_number_minted: string;
            /** @example null */
            opensea_lookup?: {
                [key: string]: unknown;
            };
            /** @example 0xdcf086e3f7954b38180daae1405569da86588bfe */
            minter_address: string;
            /** @example 0x2c8d7ec7a8439b0f67b50e93be63242de52e9b5cdfc7dc0aee80c6a2f104c41a */
            transaction_minted: string;
            /** @example null */
            frozen_log_index?: {
                [key: string]: unknown;
            };
            /** @example null */
            imported?: {
                [key: string]: unknown;
            };
            /**
             * @description When the token_uri was last updated
             * @example 2021-02-24T00:47:26.647Z
             */
            last_token_uri_sync: string;
            /**
             * @description When the metadata was last updated
             * @example 2021-02-24T00:47:26.647Z
             */
            last_metadata_sync: string;
            /**
             * Format: date-time
             * @example 2022-02-24T00:47:26.647Z
             */
            createdAt: string;
            /**
             * Format: date-time
             * @example 2022-04-09T23:56:44.807Z
             */
            updatedAt: string;
        };
        nftWalletCollections: {
            /**
             * @description The syncing status of the address [SYNCING/SYNCED]
             * @example SYNCING
             */
            status?: string;
            /**
             * @description The total number of matches for this query
             * @example 2000
             */
            total?: number;
            /**
             * @description The current page of the result
             * @example 2
             */
            page?: number;
            /**
             * @description The number of results per page
             * @example 100
             */
            page_size?: number;
            /** @description The cursor to get to the next page */
            cursor?: string;
            result?: components["schemas"]["nftCollections"][];
        };
        nftCollection: {
            /**
             * @description The total number of matches for this query
             * @example 2000
             */
            total?: number;
            /**
             * @description The current page of the result
             * @example 2
             */
            page?: number;
            /**
             * @description The number of results per page
             * @example 100
             */
            page_size?: number;
            /** @description The cursor to get to the next page */
            cursor?: string;
            result?: components["schemas"]["nft"][];
        };
        nftMetadataCollection: {
            /**
             * @description The total number of matches for this query
             * @example 2000
             */
            total?: number;
            /**
             * @description The current page of the result
             * @example 2
             */
            page?: number;
            /**
             * @description The number of results per page
             * @example 100
             */
            page_size?: number;
            result?: components["schemas"]["nftMetadata"][];
        };
        nftCollections: {
            /**
             * @description The address of the NFT contract
             * @example 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB
             */
            token_address: string;
            /**
             * @description The type of NFT contract standard
             * @example ERC721
             */
            contract_type: string;
            /**
             * @description The name of the NFT contract
             * @example CryptoKitties
             */
            name: string;
            /**
             * @description The symbol of the NFT contract
             * @example RARI
             */
            symbol: string;
        };
        nftOwner: {
            /**
             * @description The address of the NFT contract
             * @example 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB
             */
            token_address: string;
            /**
             * @description The token ID of the NFT
             * @example 15
             */
            token_id: string;
            /**
             * @description The type of NFT contract standard
             * @example ERC721
             */
            contract_type: string;
            /**
             * @description The wallet address of the owner of the NFT
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            owner_of: string;
            /**
             * @description The block number when the amount or owner changed
             * @example 88256
             */
            block_number: string;
            /**
             * @description The block number when the NFT was minted
             * @example 88256
             */
            block_number_minted: string;
            /** @description The URI to the metadata of the token */
            token_uri?: string;
            /** @description The metadata of the token */
            metadata?: string;
            /** @description A normalized metadata version of the NFT's metadata. */
            normalized_metadata?: components["schemas"]["normalizedMetadata"];
            /**
             * @description The number of this item the user owns (used by ERC1155)
             * @example 1
             */
            amount?: string;
            /**
             * @description The name of the NFT contract
             * @example CryptoKitties
             */
            name: string;
            /**
             * @description The symbol of the NFT contract
             * @example RARI
             */
            symbol: string;
            /**
             * @description The token hash
             * @example 502cee781b0fb40ea02508b21d319ced
             */
            token_hash: string;
            /**
             * @description When the token_uri was last updated
             * @example 2021-02-24T00:47:26.647Z
             */
            last_token_uri_sync: string;
            /**
             * @description When the metadata was last updated
             * @example 2021-02-24T00:47:26.647Z
             */
            last_metadata_sync: string;
        };
        normalizedMetadataAttribute: {
            /**
             * @description The trait title or descriptor
             * @example Eye Color
             */
            trait_type?: string;
            /**
             * @description The value of the attribute
             * @example hazel
             */
            value?: {
                [key: string]: unknown;
            };
            /**
             * @description The type the attribute value should be displayed as
             * @example string
             */
            display_type?: string;
            /**
             * @description For numeric values, the upper range
             * @example 100
             */
            max_value?: number;
            /**
             * @description The number of possible values for this trait
             * @example 7
             */
            trait_count?: number;
            /**
             * @description Order the trait should appear in the attribute list.
             * @example 1
             */
            order?: number;
        };
        normalizedMetadata: {
            /**
             * @description The name or title of the NFT
             * @example Moralis Mug
             */
            name?: string;
            /**
             * @description A detailed description of the NFT
             * @example Moralis Coffee nug 3D Asset that can be used in 3D worldspaces. This NFT is presented as a flat PNG, a Unity3D Prefab and a standard fbx.
             */
            description?: string;
            /**
             * @description The URL of the NFT's image
             * @example https://arw2wxg84h6b.moralishost.com:2053/server/files/tNJatzsHirx4V2VAep6sc923OYGxvkpBeJttR7Ks/de504bbadadcbe30c86278342fcf2560_moralismug.png
             */
            image?: string;
            /**
             * @description A link to additional information
             * @example https://giphy.com/gifs/loop-recursion-ting-aaODAv1iuQdgI
             */
            external_link?: string;
            /**
             * @description An animated version of the NFT's image
             * @example https://giphy.com/gifs/food-design-donuts-o9ngTPVYW4qo8
             */
            animation_url?: string;
            attributes?: components["schemas"]["normalizedMetadataAttribute"][];
        };
        nftOwnerCollection: {
            /**
             * @description The syncing status of the address [SYNCING/SYNCED]
             * @example SYNCING
             */
            status?: string;
            /**
             * @description The total number of matches for this query
             * @example 2000
             */
            total?: number;
            /**
             * @description The current page of the result
             * @example 2
             */
            page?: number;
            /**
             * @description The number of results per page
             * @example 100
             */
            page_size?: number;
            /** @description The cursor to get to the next page */
            cursor?: string;
            result?: components["schemas"]["nftOwner"][];
        };
        nftTransfer: {
            /**
             * @description The address of the NFT contract
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            token_address: string;
            /**
             * @description The token ID of the NFT
             * @example 15
             */
            token_id: string;
            /**
             * @description The address that sent the NFT
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            from_address?: string;
            /**
             * @description The address that received the NFT
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            to_address: string;
            /**
             * @description The value that was sent in the transaction (ETH/BNB/etc..)
             * @example 1000000000000000
             */
            value?: string;
            /**
             * @description The number of tokens transferred
             * @example 1
             */
            amount?: string;
            /**
             * @description The type of NFT contract standard
             * @example ERC721
             */
            contract_type: string;
            /**
             * @description The block number of the transaction
             * @example 88256
             */
            block_number: string;
            /**
             * @description The block timestamp
             * @example 2021-06-04T16:00:15
             */
            block_timestamp: string;
            /** @description The block hash of the transaction */
            block_hash: string;
            /**
             * @description The transaction hash
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            transaction_hash: string;
            /** @description The transaction type */
            transaction_type?: string;
            /** @description The transaction index */
            transaction_index?: number;
            /** @description The log index */
            log_index: number;
            /**
             * @description The operator present only for ERC1155 transfers
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            operator?: string;
        };
        nftTransferCollection: {
            /**
             * @description The total number of matches for this query
             * @example 2000
             */
            total: number;
            /**
             * @description The current page of the result
             * @example 2
             */
            page: number;
            /**
             * @description The number of results per page
             * @example 100
             */
            page_size: number;
            /** @description The cursor to get to the next page */
            cursor: string;
            result: components["schemas"]["nftTransfer"][];
            /**
             * @description Indicator if the block exists
             * @example true
             */
            block_exists?: boolean;
            /**
             * @description Indicator if the block is fully indexed
             * @example true
             */
            index_complete?: boolean;
        };
        nftContractMetadata: {
            /**
             * @description The address of the token contract
             * @example 0x2d30ca6f024dbc1307ac8a1a44ca27de6f797ec22ef20627a1307243b0ab7d09
             */
            token_address: string;
            /**
             * @description The name of the token contract
             * @example KryptoKitties
             */
            name: string;
            /** @description Timestamp of when the contract was last synced with the node */
            synced_at?: string;
            /**
             * @description The symbol of the NFT contract
             * @example RARI
             */
            symbol: string;
            /**
             * @description The type of NFT contract
             * @example ERC721
             */
            contract_type: string;
        };
        nftContractMetadataCollection: {
            /**
             * @description The total number of matches for this query
             * @example 2000
             */
            total: number;
            /**
             * @description The current page of the result
             * @example 2
             */
            page: number;
            /**
             * @description The number of results per page
             * @example 100
             */
            page_size: number;
            result: components["schemas"]["nftContractMetadata"][];
        };
        erc20Transaction: {
            /**
             * @description The transaction hash
             * @example 0x2d30ca6f024dbc1307ac8a1a44ca27de6f797ec22ef20627a1307243b0ab7d09
             */
            transaction_hash: string;
            /**
             * @description The address of the token
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            address: string;
            /**
             * @description The block timestamp
             * @example 2021-04-02T10:07:54.000Z
             */
            block_timestamp: string;
            /**
             * @description The block number
             * @example 12526958
             */
            block_number: string;
            /**
             * @description The block hash
             * @example 0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86
             */
            block_hash: string;
            /**
             * @description The recipient
             * @example 0x62AED87d21Ad0F3cdE4D147Fdcc9245401Af0044
             */
            to_address: string;
            /**
             * @description The sender
             * @example 0xd4a3BebD824189481FC45363602b83C9c7e9cbDf
             */
            from_address: string;
            /**
             * @description The value that was transferred (in wei)
             * @example 650000000000000000
             */
            value: string;
            /**
             * @description The transaction index of the transfer within the block
             * @example 12
             */
            transaction_index: number;
            /**
             * @description The log index of the transfer within the block
             * @example 2
             */
            log_index: number;
        };
        historicalNftTransfer: {
            /**
             * @description The transaction hash
             * @example 0x2d30ca6f024dbc1307ac8a1a44ca27de6f797ec22ef20627a1307243b0ab7d09
             */
            transaction_hash: string;
            /**
             * @description The address of the token
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            address: string;
            /**
             * @description The block timestamp
             * @example 2021-04-02T10:07:54.000Z
             */
            block_timestamp: string;
            /**
             * @description The block number
             * @example 12526958
             */
            block_number: string;
            /**
             * @description The block hash
             * @example 0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86
             */
            block_hash: string;
            /**
             * @description The recipient
             * @example 0x62AED87d21Ad0F3cdE4D147Fdcc9245401Af0044
             */
            to_address: string;
            /**
             * @description The sender
             * @example 0xd4a3BebD824189481FC45363602b83C9c7e9cbDf
             */
            from_address: string;
            /** @description The token ids of the tokens that were transferred */
            token_ids: string[];
            /** @description The amounts that were transferred */
            amounts: string[];
            /**
             * @description They contract type of the transfer
             * @example ERC721
             */
            contract_type: string;
        };
        erc20Metadata: {
            /**
             * @description The address of the token contract
             * @example 0x2d30ca6f024dbc1307ac8a1a44ca27de6f797ec22ef20627a1307243b0ab7d09
             */
            address: string;
            /**
             * @description The name of the token contract
             * @example Kylin Network
             */
            name: string;
            /**
             * @description The symbol of the NFT contract
             * @example KYL
             */
            symbol: string;
            /**
             * @description The number of decimals on the token
             * @example 18
             */
            decimals: string;
            /**
             * @description The logo of the token
             * @example https://cdn.moralis.io/eth/0x67b6d479c7bb412c54e03dca8e1bc6740ce6b99c.png
             */
            logo?: string;
            /**
             * @description The logo hash
             * @example ee7aa2cdf100649a3521a082116258e862e6971261a39b5cd4e4354fcccbc54d
             */
            logo_hash?: string;
            /**
             * @description The thumbnail of the logo
             * @example https://cdn.moralis.io/eth/0x67b6d479c7bb412c54e03dca8e1bc6740ce6b99c_thumb.png
             */
            thumbnail?: string;
            block_number?: string;
            validated?: string;
        };
        metadataResync: {
            /** @description The status of the resync request */
            status: string;
        };
        erc721Metadata: {
            /**
             * @description The name of the token contract
             * @example Kylin Network
             */
            name: string;
            /**
             * @description The symbol of the NFT contract
             * @example KYL
             */
            symbol: string;
            token_uri?: string;
        };
        erc20Price: {
            nativePrice?: components["schemas"]["nativeErc20Price"];
            /**
             * Format: double
             * @description The price in USD for the token
             * @example 19.722370676
             */
            usdPrice: number;
            /**
             * @description The address of the exchange used to calculate the price
             * @example 0x1f98431c8ad98523631ae4a59f267346ea31f984
             */
            exchangeAddress?: string;
            /**
             * @description The name of the exchange used to calculate the price
             * @example Uniswap v3
             */
            exchangeName?: string;
        };
        nativeErc20Price: {
            /**
             * @description The native price of the token
             * @example 8409770570506626
             */
            value: string;
            /**
             * @description The number of decimals on the token
             * @example 18
             */
            decimals: number;
            /**
             * @description The name of the token
             * @example Ether
             */
            name: string;
            /**
             * @description The symbol of the token
             * @example ETH
             */
            symbol: string;
        };
        erc20TransactionCollection: {
            /**
             * @description The total number of matches for this query
             * @example 2000
             */
            total?: number;
            /**
             * @description The current page of the result
             * @example 2
             */
            page?: number;
            /**
             * @description The number of results per page
             * @example 100
             */
            page_size?: number;
            result?: components["schemas"]["erc20Transaction"][];
        };
        ens: {
            /**
             * @description Resolved ENS address
             * @example Vitalik.eth
             */
            name: string;
        };
        resolve: {
            /**
             * @description Resolved domain address
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            address: string;
        };
        reservesPair: {
            /** @example 220969226548536862025877 */
            reserve0?: string;
            /** @example 844810441191293211036 */
            reserve1?: string;
        };
        reservesCollection: {
            token0?: {
                /** @example 0x2b591e99afe9f32eaa6214f7b7629768c40eeb39 */
                address?: string;
                /** @example HEX */
                name?: string;
                /** @example HEX */
                symbol?: string;
                /** @example 9 */
                decimals?: string;
                /** @example https://cdn.moralis.io/eth/0x2b591e99afe9f32eaa6214f7b7629768c40eeb39.png */
                logo?: string;
                /** @example b3bd1b5512965d7b6aeee903dcc6d28b116d58c788eb41e9c1690baed878beaa */
                logo_hash?: string;
                /** @example https://cdn.moralis.io/eth/0x2b591e99afe9f32eaa6214f7b7629768c40eeb39_thumb.png */
                thumbnail?: string;
                /** @example 14836562 */
                block_number?: string;
                /** @example 0 */
                validated?: number;
                /** @example 2022-01-20T09:39:55.818Z */
                created_at?: string;
            };
            token1?: {
                /** @example 0xdac17f958d2ee523a2206206994597c13d831ec7 */
                address?: string;
                /** @example Tether USD */
                name?: string;
                /** @example USDT */
                symbol?: string;
                /** @example 6 */
                decimals?: string;
                /** @example https://cdn.moralis.io/eth/0xdac17f958d2ee523a2206206994597c13d831ec7.png */
                logo?: string;
                /** @example ee7aa2cdf100649a3521a082116258e862e6971261a39b5cd4e4354fcccbc54d */
                logo_hash?: string;
                /** @example https://cdn.moralis.io/eth/0xdac17f958d2ee523a2206206994597c13d831ec7_thumb.png */
                thumbnail?: string;
                /** @example 4638568 */
                block_number?: string;
                /** @example 1 */
                validated?: number;
                /** @example 2022-01-20T09:39:55.818Z */
                created_at?: string;
            };
            /** @example 0xbbb9bf440d0f686487925fef3b0a0f9aa67753f6 */
            pairAddress?: string;
        };
        ipfsFileRequest: {
            /**
             * @description Path to the file
             * @example moralis/logo.jpg
             */
            path: string;
            /**
             * @description Base64 or JSON
             * @example iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3
             */
            content: string;
        };
        ipfsFile: {
            /**
             * @description Path to the file
             * @example https://ipfs.moralis.io/QmPQ3YJ3hgfsBzJ1U4MGyV2C1GhDy6MWCENr1qMdMpKVnY/moralis/logo.jpg
             */
            path: string;
        };
        web3version: {
            /**
             * @description The version of the API
             * @example 1.0.0
             */
            version: string;
        };
        endpointWeights: {
            /**
             * @description endpoint
             * @example endpointWeights
             */
            endpoint: string;
            /**
             * @description The path to the endpoint
             * @example /info/endpointWeights
             */
            path: string;
            /**
             * @description The number of hits the request counts towards rate limiting
             * @example 1
             */
            rateLimitWeight: string;
            /**
             * @description The number of compute units the request counts towards billing
             * @example 0
             */
            price: string;
        };
    };
}
export interface operations {
    /**
     * Get NFTs owned by a given address.
     * * The response will include status [SYNCED/SYNCING] based on the contracts being indexed.
     * * Use the token_address param to get results for a specific contract only
     * * Note that results will include all indexed NFTs
     * * Any request that includes the token_address param will start the indexing process for that NFT collection the very first time it is requested.
     */
    getWalletNFTs: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The format of the token ID */
                format?: "decimal" | "hex";
                /** The desired page size of the result. */
                limit?: number;
                /** The addresses to get balances for (optional) */
                token_addresses?: string[];
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
                /** Should normalized metadata be returned? */
                normalizeMetadata?: boolean;
            };
            path: {
                /** The address of the wallet */
                address: string;
            };
        };
        responses: {
            /** Returns a collection of NFT owners */
            200: {
                content: {
                    "application/json": components["schemas"]["nftOwnerCollection"];
                };
            };
        };
    };
    /** Get transfers of NFTs given the wallet and other parameters. */
    getWalletNFTTransfers: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The format of the token ID */
                format?: "decimal" | "hex";
                /** The transfer direction */
                direction?: "both" | "to" | "from";
                /**
                 * The minimum block number from which to get the transfers
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_block?: number;
                /** To get the reserves at this block number */
                to_block?: string;
                /** The desired page size of the result. */
                limit?: number;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
            };
            path: {
                /** The wallet address of the sender or recipient of the transfers */
                address: string;
            };
        };
        responses: {
            /** Returns a collection of NFT transfers */
            200: {
                content: {
                    "application/json": components["schemas"]["nftTransferCollection"];
                };
            };
        };
    };
    /** Get NFT collections owned by a given wallet address. */
    getWalletNFTCollections: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The desired page size of the result. */
                limit?: number;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
            };
            path: {
                /** The wallet address of the owner of NFTs in the collections */
                address: string;
            };
        };
        responses: {
            /** Returns the NFT collections owned by a wallet */
            200: {
                content: {
                    "application/json": components["schemas"]["nftWalletCollections"];
                };
            };
        };
    };
    /**
     * Get NFTs for a given contract address, including metadata for all NFTs (where available).
     * * Results are limited to 100 per page by default
     * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection.
     */
    getContractNFTs: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The format of the token ID */
                format?: "decimal" | "hex";
                /** The desired page size of the result. */
                limit?: number;
                /** The number of subranges to split the results into */
                totalRanges?: number;
                /** The desired subrange to query */
                range?: number;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
                /** Should normalized metadata be returned? */
                normalizeMetadata?: boolean;
            };
            path: {
                /** The address of the NFT contract */
                address: string;
            };
        };
        responses: {
            /** Returns a collection of NFTs */
            200: {
                content: {
                    "application/json": components["schemas"]["nftCollection"];
                };
            };
        };
    };
    /**
     * Get owners of NFTs for a given contract.
     * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection.
     */
    getNFTOwners: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The format of the token ID */
                format?: "decimal" | "hex";
                /** The desired page size of the result. */
                limit?: number;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
                /** Should normalized metadata be returned? */
                normalizeMetadata?: boolean;
            };
            path: {
                /** The address of the NFT contract */
                address: string;
            };
        };
        responses: {
            /** Returns a collection of NFT owners */
            200: {
                content: {
                    "application/json": components["schemas"]["nftOwnerCollection"];
                };
            };
        };
    };
    /** Get transfers of NFTs for a given contract and other parameters. */
    getNFTContractTransfers: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The format of the token ID */
                format?: "decimal" | "hex";
                /** The desired page size of the result. */
                limit?: number;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
            };
            path: {
                /** The address of the NFT contract */
                address: string;
            };
        };
        responses: {
            /** Returns a collection of NFT transfers */
            200: {
                content: {
                    "application/json": components["schemas"]["nftTransferCollection"];
                };
            };
        };
    };
    /** Get transfers of NFTs from a block number to a block number. */
    getNFTTransfersFromToBlock: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /**
                 * The minimum block number from which to get the transfers
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_block?: number;
                /**
                 * The maximum block number from which to get the transfers.
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_block?: number;
                /**
                 * The start date from which to get the transfers (any format that is accepted by momentjs)
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_date?: string;
                /**
                 * The end date from which to get the transfers (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_date?: string;
                /** The format of the token ID */
                format?: "decimal" | "hex";
                /** The desired page size of the result. */
                limit?: number;
                /** The cursor returned in the previous response (for getting the next page) */
                cursor?: string;
            };
        };
        responses: {
            /** Returns a collection of NFT transfers */
            200: {
                content: {
                    "application/json": components["schemas"]["nftTransferCollection"];
                };
            };
        };
    };
    /** Get transfers of NFTs given a block number or block hash. */
    getNFTTransfersByBlock: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The subdomain of the Moralis server to use (only use when selecting local devchain as chain) */
                subdomain?: string;
                /** The desired page size of the result. */
                limit?: number;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
            };
            path: {
                /** The block number or block hash */
                block_number_or_hash: string;
            };
        };
        responses: {
            /** Returns the contents of a block */
            200: {
                content: {
                    "application/json": components["schemas"]["nftTransferCollection"];
                };
            };
        };
    };
    /** Get trades of NFTs for a given contract and marketplace. */
    getNFTTrades: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /**
                 * The minimum block number from which to get the transfers
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_block?: number;
                /** The block number to get the trades from */
                to_block?: string;
                /**
                 * The start date from which to get the transfers (any format that is accepted by momentjs)
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_date?: string;
                /**
                 * The end date from which to get the transfers (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_date?: string;
                /** The web3 provider URL to use when using local dev chain */
                provider_url?: string;
                /** Marketplace from which to get the trades (only OpenSea is supported at the moment) */
                marketplace?: "opensea";
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
                /** The desired page size of the result. */
                limit?: number;
            };
            path: {
                /** The address of the NFT contract */
                address: string;
            };
        };
        responses: {
            /** Returns the trades */
            200: {
                content: {
                    "application/json": components["schemas"]["tradeCollection"];
                };
            };
        };
    };
    /**
     * Get the collection / contract level metadata for a given contract (name, symbol, base token URI).
     * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     */
    getNFTContractMetadata: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
            };
            path: {
                /** The address of the NFT contract */
                address: string;
            };
        };
        responses: {
            /** Returns the metadata for an NFT collection. */
            200: {
                content: {
                    "application/json": components["schemas"]["nftContractMetadata"];
                };
            };
        };
    };
    /**
     * Get NFT data, including metadata (where available), for the given NFT token ID and contract address.
     * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     */
    getNFTMetadata: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The format of the token ID */
                format?: "decimal" | "hex";
                /** Should normalized metadata be returned? */
                normalizeMetadata?: boolean;
            };
            path: {
                /** The address of the NFT contract */
                address: string;
                /** The ID of the token */
                token_id: string;
            };
        };
        responses: {
            /** Returns the specified NFT. */
            200: {
                content: {
                    "application/json": components["schemas"]["nft"];
                };
            };
        };
    };
    /** Get transfers of an NFT given a contract address and token ID. */
    getNFTTransfers: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The format of the token ID */
                format?: "decimal" | "hex";
                /** The desired page size of the result. */
                limit?: number;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
            };
            path: {
                /** The address of the NFT contract */
                address: string;
                /** The ID of the token */
                token_id: string;
            };
        };
        responses: {
            /** Returns a collection of NFT transfers */
            200: {
                content: {
                    "application/json": components["schemas"]["nftTransferCollection"];
                };
            };
        };
    };
    /**
     * Get owners of a specific NFT given the contract address and token ID.
     * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     */
    getNFTTokenIdOwners: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The format of the token ID */
                format?: "decimal" | "hex";
                /** The desired page size of the result. */
                limit?: number;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
                /** Should normalized metadata be returned? */
                normalizeMetadata?: boolean;
            };
            path: {
                /** The address of the NFT contract */
                address: string;
                /** The ID of the token */
                token_id: string;
            };
        };
        responses: {
            /** Returns a collection of NFTs with their respective owners. */
            200: {
                content: {
                    "application/json": components["schemas"]["nftOwnerCollection"];
                };
            };
        };
    };
    /** Initiates a sync of a previously non synced contract. */
    syncNFTContract: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
            };
            path: {
                /** The address of the NFT contract */
                address: string;
            };
        };
        responses: {
            /** Contract address was triggered for index. */
            201: unknown;
        };
    };
    /**
     * Resync the metadata for an NFT
     * * The metadata flag will request the NFT's metadata from an already existing token_uri
     * * The URI (default) flag will fetch the latest token_uri from the given NFT contract address. In sync mode the metadata will also be fetched
     * * The sync mode will make the endpoint synchronous so it will wait for the task to be completed before responding
     * * The async mode (default) will make the endpoint asynchronous so we will wait for the task to be completed before responding
     */
    reSyncMetadata: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The type of resync to operate */
                flag?: "URI" | "metadata";
                /** To define the behaviour of the endpoint */
                mode?: "async" | "sync";
            };
            path: {
                /** The address of the NFT contract */
                address: string;
                /** The ID of the token */
                token_id: string;
            };
        };
        responses: {
            /** (In sync mode) Resync request executed. */
            200: {
                content: {
                    "application/json": components["schemas"]["metadataResync"];
                };
            };
            /** The resync request was received and will be executed. */
            202: {
                content: {
                    "application/json": components["schemas"]["metadataResync"];
                };
            };
            /** (In sync mode) Resync request executed and metadata could not be updated. */
            404: {
                content: {
                    "application/json": components["schemas"]["metadataResync"];
                };
            };
        };
    };
    /** Get the lowest executed price for an NFT contract for the last x days (only trades paid in ETH). */
    getNFTLowestPrice: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /**
                 * The number of days to look back to find the lowest price
                 * If not provided 7 days will be the default
                 */
                days?: number;
                /** The web3 provider URL to use when using local dev chain */
                provider_url?: string;
                /** Marketplace from which to get the trades (only OpenSea is supported at the moment) */
                marketplace?: "opensea";
            };
            path: {
                /** The address of the NFT contract */
                address: string;
            };
        };
        responses: {
            /** Returns the trade with the lowest price */
            200: {
                content: {
                    "application/json": components["schemas"]["trade"];
                };
            };
        };
    };
    /** Get NFTs that match a given metadata search query. */
    searchNFTs: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The format of the token ID */
                format?: "decimal" | "hex";
                /** The search string */
                q: string;
                /** What fields the search should match on. To look into the entire metadata set the value to 'global'. To have a better response time you can look into a specific field like name */
                filter?: "name" | "description" | "attributes" | "global" | "name,description" | "name,attributes" | "description,attributes" | "name,description,attributes";
                /**
                 * The minimum block number from which to start the search
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_block?: number;
                /**
                 * The maximum block number from which to end the search
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_block?: number;
                /**
                 * The date from which to start the search (any format that is accepted by momentjs)
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_date?: string;
                /**
                 * Get search results up until this date (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_date?: string;
                /** The addresses to get metadata for */
                addresses?: string[];
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
                /** The desired page size of the result. */
                limit?: number;
            };
        };
        responses: {
            /** Returns the matching NFTs */
            200: {
                content: {
                    "application/json": components["schemas"]["nftMetadataCollection"];
                };
            };
        };
    };
    /** Get the token price denominated in the blockchain's native token and USD. */
    getTokenPrice: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The web3 provider URL to use when using local dev chain */
                providerUrl?: string;
                /** The factory name or address of the token exchange */
                exchange?: string;
                /** The block number from which the token price should be checked */
                to_block?: number;
            };
            path: {
                /** The address of the token contract */
                address: string;
            };
        };
        responses: {
            /** Returns the price denominated in the blockchain's native token and USD for a given token contract address */
            200: {
                content: {
                    "application/json": components["schemas"]["erc20Price"];
                };
            };
        };
    };
    /** Get token balances for a specific wallet address. */
    getWalletTokenBalances: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The subdomain of the Moralis server to use (only use when selecting local devchain as chain) */
                subdomain?: string;
                /** The block number from which the balances should be checked */
                to_block?: number;
                /** The addresses to get balances for (optional) */
                token_addresses?: string[];
            };
            path: {
                /** The address from which token balances will be checked */
                address: string;
            };
        };
        responses: {
            /** Returns token balances for a specific address */
            200: {
                content: {
                    "application/json": components["schemas"]["erc20TokenBalance"][];
                };
            };
        };
    };
    /** Get ERC20 token transactions ordered by block number in descending order. */
    getWalletTokenTransfers: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The subdomain of the Moralis server to use (only use when selecting local devchain as chain) */
                subdomain?: string;
                /**
                 * The minimum block number from which to get the transactions
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_block?: number;
                /**
                 * The maximum block number from which to get the transactions.
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_block?: number;
                /**
                 * The start date from which to get the transactions (any format that is accepted by momentjs)
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_date?: string;
                /**
                 * Get the transactions up to this date (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_date?: string;
                /** The desired page size of the result. */
                limit?: number;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
            };
            path: {
                /** The address of the wallet */
                address: string;
            };
        };
        responses: {
            /** Returns a collection of token transactions. */
            200: {
                content: {
                    "application/json": components["schemas"]["erc20TransactionCollection"];
                };
            };
        };
    };
    /** Get the metadata for a given token contract address (name, symbol, decimals, logo). */
    getTokenMetadata: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The subdomain of the Moralis server to use (only use when selecting local devchain as chain) */
                subdomain?: string;
                /** The web3 provider URL to use when using local dev chain */
                providerUrl?: string;
                /** The addresses to get metadata for */
                addresses: string[];
            };
        };
        responses: {
            /** Get the metadata for a given ERC20 token contract address (name, symbol, decimals, logo). */
            200: {
                content: {
                    "application/json": components["schemas"]["erc20Metadata"][];
                };
            };
        };
    };
    /** Get the metadata for a list of token symbols (name, symbol, decimals, logo). */
    getTokenMetadataBySymbol: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The subdomain of the Moralis server to use (only use when selecting local devchain as chain) */
                subdomain?: string;
                /** The symbols to get metadata for */
                symbols: string[];
            };
        };
        responses: {
            /** Returns metadata for a given token contract address (name, symbol, decimals, logo). */
            200: {
                content: {
                    "application/json": components["schemas"]["erc20Metadata"][];
                };
            };
        };
    };
    /** Get the amount which the spender is allowed to withdraw on behalf of the owner. */
    getTokenAllowance: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The web3 provider URL to use when using local dev chain */
                providerUrl?: string;
                /** The address of the token owner */
                owner_address: string;
                /** The address of the token spender */
                spender_address: string;
            };
            path: {
                /** The address of the token contract */
                address: string;
            };
        };
        responses: {
            /** Returns the amount which the spender is allowed to withdraw on behalf of the owner. */
            200: {
                content: {
                    "application/json": components["schemas"]["erc20Allowance"];
                };
            };
        };
    };
    /** Get ERC20 token transactions from a contract ordered by block number in descending order. */
    getTokenTransfers: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The subdomain of the Moralis server to use (only use when selecting local devchain as chain) */
                subdomain?: string;
                /**
                 * The minimum block number from which to get the transfers
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_block?: number;
                /**
                 * The maximum block number from which to get the transfers.
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_block?: number;
                /**
                 * The start date from which to get the transfers (any format that is accepted by momentjs)
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_date?: string;
                /**
                 * Get the transfers up to this date (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_date?: string;
                /** offset */
                offset?: number;
                /** The desired page size of the result. */
                limit?: number;
            };
            path: {
                /** The address of the token contract */
                address: string;
            };
        };
        responses: {
            /** Returns a collection of token contract transactions. */
            200: {
                content: {
                    "application/json": components["schemas"]["erc20TransactionCollection"];
                };
            };
        };
    };
    /** Get the native balance for a specific wallet address. */
    getNativeBalance: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The web3 provider URL to use when using local dev chain */
                providerUrl?: string;
                /** The block number from which the balances should be checked */
                to_block?: number;
            };
            path: {
                /** The address from which the native balance will be checked */
                address: string;
            };
        };
        responses: {
            /** Returns the native balance for a specific address */
            200: {
                content: {
                    "application/json": components["schemas"]["nativeBalance"];
                };
            };
        };
    };
    /** Get native transactions ordered by block number in descending order. */
    getWalletTransactions: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The subdomain of the Moralis server to use (only use when selecting local devchain as chain) */
                subdomain?: string;
                /**
                 * The minimum block number from which to get the transactions
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_block?: number;
                /**
                 * The maximum block number from which to get the transactions.
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_block?: number;
                /**
                 * The start date from which to get the transactions (any format that is accepted by momentjs)
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_date?: string;
                /**
                 * Get the transactions up to this date (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_date?: string;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
                /** The desired page size of the result. */
                limit?: number;
            };
            path: {
                /** The address of the wallet */
                address: string;
            };
        };
        responses: {
            /** Returns a collection of native transactions. */
            200: {
                content: {
                    "application/json": components["schemas"]["transactionCollection"];
                };
            };
        };
    };
    /** Get the contents of a transaction by the given transaction hash. */
    getTransaction: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The subdomain of the Moralis server to use (only use when selecting local devchain as chain) */
                subdomain?: string;
            };
            path: {
                /** The transaction hash */
                transaction_hash: string;
            };
        };
        responses: {
            /** Transaction details by transaction hash */
            200: {
                content: {
                    "application/json": components["schemas"]["blockTransaction"];
                };
            };
        };
    };
    /** Get the contents of a block given the block hash. */
    getBlock: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The subdomain of the Moralis server to use (only use when selecting local devchain as chain) */
                subdomain?: string;
            };
            path: {
                /** The block number or block hash */
                block_number_or_hash: string;
            };
        };
        responses: {
            /** Returns the contents of a block */
            200: {
                content: {
                    "application/json": components["schemas"]["block"];
                };
            };
        };
    };
    /** Get the closest block given the date. */
    getDateToBlock: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The web3 provider URL to use when using local dev chain */
                providerUrl?: string;
                /** Unix date in milliseconds or a datestring (any format that is accepted by momentjs) */
                date: string;
            };
        };
        responses: {
            /** Returns the block number and corresponding date and timestamp */
            200: {
                content: {
                    "application/json": components["schemas"]["blockDate"];
                };
            };
        };
    };
    /** Get the logs for a contract. */
    getContractLogs: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The subdomain of the Moralis server to use (only use when selecting local devchain as chain) */
                subdomain?: string;
                /**
                 * The block number
                 * * Provide the param 'block_numer' or ('from_block' and / or 'to_block')
                 * * If 'block_numer' is provided in combination with 'from_block' and / or 'to_block', 'block_number' will will be used
                 */
                block_number?: string;
                /**
                 * The minimum block number from which to get the logs
                 * * Provide the param 'block_numer' or ('from_block' and / or 'to_block')
                 * * If 'block_numer' is provided in combination with 'from_block' and / or 'to_block', 'block_number' will will be used
                 */
                from_block?: string;
                /**
                 * The maximum block number from which to get the logs
                 * * Provide the param 'block_numer' or ('from_block' and / or 'to_block')
                 * * If 'block_numer' is provided in combination with 'from_block' and / or 'to_block', 'block_number' will will be used
                 */
                to_block?: string;
                /**
                 * The start date from which to get the logs (any format that is accepted by momentjs)
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 * * If 'from_date' and the block params are provided, the block params will be used. Please refer to the blocks params sections (block_number,from_block and to_block) on how to use them
                 */
                from_date?: string;
                /**
                 * Get the logs up to this date (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 * * If 'to_date' and the block params are provided, the block params will be used. Please refer to the blocks params sections (block_number,from_block and to_block) on how to use them
                 */
                to_date?: string;
                /** topic0 */
                topic0?: string;
                /** topic1 */
                topic1?: string;
                /** topic2 */
                topic2?: string;
                /** topic3 */
                topic3?: string;
                /** The desired page size of the result. */
                limit?: number;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
            };
            path: {
                /** The address of the contract */
                address: string;
            };
        };
        responses: {
            /** Returns the logs for an address */
            200: {
                content: {
                    "application/json": components["schemas"]["logCollection"];
                };
            };
        };
    };
    /** Get events for a contract ordered by block number in descending order. */
    getContractEvents: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The subdomain of the Moralis server to use (only use when selecting local devchain as chain) */
                subdomain?: string;
                /** The web3 provider URL to use when using local dev chain */
                providerUrl?: string;
                /**
                 * The minimum block number from which to get the logs
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_block?: number;
                /**
                 * The maximum block number from which to get the logs.
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_block?: number;
                /**
                 * The start date from which to get the logs (any format that is accepted by momentjs)
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_date?: string;
                /**
                 * Get the logs up to this date (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_date?: string;
                /** The topic of the event */
                topic: string;
                /** offset */
                offset?: number;
                /** The desired page size of the result. */
                limit?: number;
            };
            path: {
                /** The address of the contract */
                address: string;
            };
        };
        responses: {
            /** Returns a collection of events by topic */
            200: {
                content: {
                    "application/json": {
                        /**
                         * @description The total number of matches for this query
                         * @example 2000
                         */
                        total?: number;
                        /**
                         * @description The current page of the result
                         * @example 2
                         */
                        page?: number;
                        /**
                         * @description The number of results per page
                         * @example 100
                         */
                        page_size?: number;
                        result?: components["schemas"]["logEvent"][];
                    };
                };
            };
        };
        /** ABI of the specific event */
        requestBody: {
            content: {
                "application/json": {
                    [key: string]: unknown;
                };
            };
        };
    };
    /** Run a given function of a contract ABI and retrieve readonly data. */
    runContractFunction: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The subdomain of the Moralis server to use (only use when selecting local devchain as chain) */
                subdomain?: string;
                /** The web3 provider URL to use when using local dev chain */
                providerUrl?: string;
                /** The function name of the contract */
                function_name: string;
            };
            path: {
                /** The address of the contract */
                address: string;
            };
        };
        responses: {
            /** Returns response of the function executed */
            200: {
                content: {
                    "application/json": string;
                };
            };
        };
        /** Body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["RunContractDto"];
            };
        };
    };
    /** Get the current version of the Moralis Web3 API. */
    web3ApiVersion: {
        responses: {
            /** Get the current version of the Moralis Web3 API. */
            200: {
                content: {
                    "application/json": components["schemas"]["web3version"];
                };
            };
        };
    };
    /** Get the cost and rate limit for each API endpoint. */
    endpointWeights: {
        responses: {
            /** The cost and rate limit for each API endpoint. */
            200: {
                content: {
                    "application/json": components["schemas"]["endpointWeights"][];
                };
            };
        };
    };
    /** Resolve an ETH address and find the ENS name. */
    resolveAddress: {
        parameters: {
            path: {
                /** The address to be resolved */
                address: string;
            };
        };
        responses: {
            /** Returns an ENS */
            200: {
                content: {
                    "application/json": components["schemas"]["ens"];
                };
            };
        };
    };
    /** Resolve an Unstoppable domain and get the address. */
    resolveDomain: {
        parameters: {
            query: {
                /** The currency to query */
                currency?: "eth" | "0x1";
            };
            path: {
                /** The domain to be resolved */
                domain: string;
            };
        };
        responses: {
            /** Returns an address */
            200: {
                content: {
                    "application/json": components["schemas"]["resolve"];
                };
            };
            /** Returns an address */
            404: {
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
        };
    };
    /** Get the liquidity reserves for a given pair address. Only Uniswap V2 based exchanges supported at the moment. */
    getPairReserves: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The block number to get the reserves from */
                to_block?: string;
                /**
                 * Get the reserves up to this date (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_date?: string;
                /** The web3 provider URL to use when using local dev chain */
                provider_url?: string;
            };
            path: {
                /** The liquidity pair address */
                pair_address: string;
            };
        };
        responses: {
            /** Returns the pair reserves */
            200: {
                content: {
                    "application/json": {
                        /** @example 220969226548536862025877 */
                        reserve0?: string;
                        /** @example 844810441191293211036 */
                        reserve1?: string;
                    };
                };
            };
        };
    };
    /**
     * Fetch the pair data of the provided token0+token1 combination.
     * The token0 and token1 options are interchangable (ie. there is no different outcome in "token0=WETH and token1=USDT" or "token0=USDT and token1=WETH")
     */
    getPairAddress: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The block number to get the reserves from */
                to_block?: string;
                /**
                 * Get the reserves up to this date (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_date?: string;
                /** The factory name or address of the token exchange */
                exchange: "uniswapv2" | "uniswapv3" | "sushiswapv2" | "pancakeswapv2" | "pancakeswapv1" | "quickswap";
            };
            path: {
                /** The token0 address */
                token0_address: string;
                /** The token1 address */
                token1_address: string;
            };
        };
        responses: {
            /** Returns the pair address of the two tokens. */
            200: {
                content: {
                    "application/json": components["schemas"]["reservesCollection"];
                };
            };
        };
    };
    /** Upload multiple files to IPFS and place them in a folder directory. */
    uploadFolder: {
        responses: {
            /** Returns the path to the uploaded files */
            200: {
                content: {
                    "application/json": components["schemas"]["ipfsFile"][];
                };
            };
        };
        /** Array of JSON and Base64 Supported */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ipfsFileRequest"][];
            };
        };
    };
}
export interface external {
}
//# sourceMappingURL=openapi.d.ts.map