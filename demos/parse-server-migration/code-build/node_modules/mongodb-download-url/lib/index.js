"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.clearCache = exports.getDownloadURL = void 0;
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const semver_1 = __importDefault(require("semver"));
const version_list_1 = require("./version-list");
Object.defineProperty(exports, "clearCache", { enumerable: true, get: function () { return version_list_1.clearCache; } });
const linux_distro_1 = require("./linux-distro");
const util_1 = require("util");
const debug_1 = __importDefault(require("debug"));
const debug = debug_1.default('mongodb-download-url');
function getPriority(values, candidate) {
    for (const { value, priority } of values) {
        if (value === candidate) {
            return priority;
        }
    }
    return 0;
}
function maximizer(values, evaluator) {
    let max = -Infinity;
    let maximizer;
    for (const v of values) {
        const result = evaluator(v);
        if (result > max) {
            max = result;
            maximizer = v;
        }
    }
    return maximizer;
}
function parseArch(arch) {
    if (['i686', 'i386', 'x86', 'ia32'].includes(arch)) {
        return ['i686', 'i386', 'x86', 'ia32'];
    }
    if (['x86_64', 'x64'].includes(arch)) {
        return ['x86_64', 'x64'];
    }
    if (['arm64', 'aarch64'].includes(arch)) {
        return ['arm64', 'aarch64'];
    }
    if (['ppc64', 'ppc64le'].includes(arch)) {
        return ['ppc64', 'ppc64le'];
    }
    return [arch];
}
async function parseTarget(distro, platform, archs, version) {
    if (platform === 'linux') {
        const results = [];
        if (distro) {
            results.push({ value: distro, priority: 1000 });
            if (archs.includes('x86_64')) {
                if (distro === 'amzn64' || distro === 'amazon1') {
                    results.push({ value: 'amazon', priority: 900 });
                }
                if (distro === 'amazon' || distro === 'amazon1') {
                    results.push({ value: 'amzn64', priority: 900 });
                }
            }
        }
        if (archs.includes('x86_64')) {
            results.push({ value: 'linux_x86_64', priority: 1 });
        }
        else if (archs.includes('i686')) {
            results.push({ value: 'linux_i686', priority: 1 });
        }
        let distroResultsErr;
        try {
            results.push(...await linux_distro_1.getCurrentLinuxDistro());
        }
        catch (err) {
            distroResultsErr = err;
        }
        if (distro === undefined &&
            distroResultsErr &&
            (version === '*' ||
                version === 'latest-alpha' ||
                semver_1.default.gte(version, '4.0.0'))) {
            throw distroResultsErr;
        }
        return results;
    }
    else if (platform === 'sunos') {
        return [{ value: 'sunos5', priority: 1 }];
    }
    else if (['win32', 'windows'].includes(platform)) {
        if (archs.includes('i686')) {
            return [
                { value: 'windows', priority: 1 },
                { value: 'windows_i686', priority: 10 }
            ];
        }
        else {
            return [
                { value: 'windows', priority: 1 },
                { value: 'windows_x86_64', priority: 10 },
                { value: 'windows_x86_64-2008plus', priority: 10 },
                { value: 'windows_x86_64-2008plus-ssl', priority: 100 },
                { value: 'windows_x86_64-2012plus', priority: 100 }
            ];
        }
    }
    else if (['darwin', 'osx', 'macos'].includes(platform)) {
        return [
            { value: 'osx', priority: 1 },
            { value: 'osx-ssl', priority: 10 },
            { value: 'darwin', priority: 1 },
            { value: 'macos', priority: 1 }
        ];
    }
    return [{ value: platform, priority: 1 }];
}
async function resolve(opts) {
    var _a, _b, _c, _d, _e;
    let download;
    if (opts.version === 'latest-alpha' && opts.enterprise) {
        const targets = opts.target.map(({ value }) => value);
        let url, target;
        if (targets.includes('macos')) {
            url = 'https://downloads.mongodb.com/osx/mongodb-macos-x86_64-enterprise-latest.tgz';
            target = 'macos';
        }
        else if (targets.includes('linux_x86_64')) {
            target = maximizer(opts.target, candidate => candidate.priority).value;
            url = `https://downloads.mongodb.com/linux/mongodb-linux-x86_64-enterprise-${target}-latest.tgz`;
        }
        else if (targets.includes('windows_x86_64')) {
            target = 'windows';
            url = 'https://downloads.mongodb.com/windows/mongodb-windows-x86_64-enterprise-latest.zip';
        }
        if (url) {
            download = {
                target,
                edition: 'enterprise',
                arch: 'x86_64',
                archive: {
                    url,
                    sha1: '',
                    sha256: '',
                    debug_symbols: ''
                }
            };
        }
    }
    let version;
    if (!download) {
        version = await version_list_1.getVersion(opts);
        if (!version) {
            throw new Error(`Could not find version matching ${util_1.inspect(opts)}`);
        }
        const bestDownload = maximizer(version.downloads.map((candidate) => {
            if (opts.enterprise) {
                if (candidate.edition !== 'enterprise') {
                    return { value: candidate, priority: 0 };
                }
            }
            else {
                if (candidate.edition !== 'targeted' && candidate.edition !== 'base') {
                    return { value: candidate, priority: 0 };
                }
            }
            if (!opts.arch.includes(candidate.arch)) {
                return { value: candidate, priority: 0 };
            }
            const targetPriority = getPriority(opts.target, candidate.target);
            return { value: candidate, priority: targetPriority };
        }), (candidate) => candidate.priority);
        if (bestDownload.priority > 0) {
            download = bestDownload.value;
        }
    }
    if (!download) {
        throw new Error(`Could not find download URL for version ${version === null || version === void 0 ? void 0 : version.version} ${util_1.inspect(opts)}`);
    }
    const wantsCryptd = opts.cryptd && download.target;
    const wantsCryptShared = opts.crypt_shared && download.target;
    if (wantsCryptShared && !download.crypt_shared && !download.csfle) {
        throw new Error(`No crypt_shared library download for version ${version === null || version === void 0 ? void 0 : version.version} available ${util_1.inspect(opts)}`);
    }
    debug('fully resolved', JSON.stringify(opts, null, 2), download);
    let { url } = wantsCryptShared
        ? ((_a = download.crypt_shared) !== null && _a !== void 0 ? _a : download.csfle)
        : ((_b = (wantsCryptd ? download.cryptd : null)) !== null && _b !== void 0 ? _b : download.archive);
    if (wantsCryptd) {
        url = url.replace('mongodb-shell-windows', 'mongodb-cryptd-windows');
    }
    return {
        ...opts,
        name: 'mongodb',
        url: url,
        arch: download.arch,
        distro: download.target,
        platform: download.target,
        filenamePlatform: download.target,
        version: (_c = version === null || version === void 0 ? void 0 : version.version) !== null && _c !== void 0 ? _c : '*',
        artifact: path_1.default.basename(url),
        debug: false,
        enterprise: download.edition === 'enterprise',
        branch: 'master',
        bits: ['i386', 'i686'].includes(download.arch) ? '32' : '64',
        ext: (_e = (_d = url.match(/\.([^.]+)$/)) === null || _d === void 0 ? void 0 : _d[1]) !== null && _e !== void 0 ? _e : 'tgz'
    };
}
async function options(opts = {}) {
    var _a;
    if (typeof opts === 'string') {
        opts = {
            version: opts
        };
    }
    else {
        opts = { ...opts };
    }
    (_a = opts.crypt_shared) !== null && _a !== void 0 ? _a : (opts.crypt_shared = opts.csfle);
    if (opts.cryptd && opts.crypt_shared) {
        throw new Error('Cannot request both cryptd and csfle package');
    }
    if (opts.bits && !opts.arch) {
        opts.arch = +opts.bits === 32 ? 'ia32' : 'x64';
    }
    if (!opts.arch) {
        opts.arch = os_1.default.arch();
    }
    if (!opts.platform) {
        opts.platform = os_1.default.platform();
    }
    if (!opts.version) {
        opts.version = process.env.MONGODB_VERSION || 'stable';
    }
    if (opts.version === 'stable' || opts.version === 'latest' || opts.version === '*') {
        opts.version = '*';
        opts.productionOnly = true;
    }
    else if (opts.version === 'unstable') {
        opts.version = '*';
        opts.productionOnly = false;
    }
    const processedOptions = {
        ...opts,
        arch: parseArch(opts.arch),
        target: [],
        enterprise: !!opts.enterprise,
        cryptd: !!opts.cryptd,
        crypt_shared: !!opts.crypt_shared,
        version: opts.version
    };
    processedOptions.target = await parseTarget(opts.distro, opts.platform, processedOptions.arch, processedOptions.version);
    return processedOptions;
}
async function getDownloadURL(opts) {
    const parsedOptions = await options(opts);
    debug('Building URL for options `%j`', parsedOptions);
    return await resolve(parsedOptions);
}
exports.getDownloadURL = getDownloadURL;
exports.default = getDownloadURL;
//# sourceMappingURL=index.js.map