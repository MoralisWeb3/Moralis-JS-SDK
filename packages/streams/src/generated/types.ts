/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/history": {
    get: operations["GetHistory"];
  };
  "/history/replay/{id}": {
    /** Replay a specific history. */
    post: operations["ReplayHistory"];
  };
  "/settings": {
    /** Get the settings for the current project based on the project api-key. */
    get: operations["GetSettings"];
    /** Set the settings for the current project based on the project api-key. */
    post: operations["SetSettings"];
  };
  "/beta/stats": {
    /** Get the stats for the current project based on the project api-key (Beta - This endpoint could be replaced or removed). */
    get: operations["GetStats"];
  };
  "/streams/evm": {
    /** Get all the evm streams for the current project based on the project api-key. */
    get: operations["GetStreams"];
    /** Creates a new evm stream. */
    put: operations["CreateStream"];
  };
  "/streams/evm/{id}": {
    /** Get a specific evm stream. */
    get: operations["GetStream"];
    /** Updates a specific evm stream. */
    post: operations["UpdateStream"];
    /** Delete a specific evm stream. */
    delete: operations["DeleteStream"];
  };
  "/streams/evm/{id}/status": {
    /** Updates the status of specific evm stream. */
    post: operations["UpdateStreamStatus"];
  };
}

export interface components {
  schemas: {
    WebhookBlock: {
      number: string;
      hash: string;
      timestamp: string;
    };
    Log: {
      logIndex: string;
      transactionHash: string;
      address: string;
      data: string | null;
      topic0: string | null;
      topic1: string | null;
      topic2: string | null;
      topic3: string | null;
    };
    Transaction: {
      hash: string;
      gas: string | null;
      gasPrice: string | null;
      nonce: string | null;
      input: string | null;
      transactionIndex: string;
      fromAddress: string;
      toAddress: string | null;
      value: string | null;
      type: string | null;
      v: string | null;
      r: string | null;
      s: string | null;
      receiptCumulativeGasUsed: string | null;
      receiptGasUsed: string | null;
      receiptContractAddress: string | null;
      receiptRoot: string | null;
      receiptStatus: string | null;
    };
    InternalTransaction: {
      from: string | null;
      to: string | null;
      value: string | null;
      transactionHash: string;
      gas: string | null;
    };
    AbiInput: {
      name: string;
      type: string;
      indexed?: boolean;
      components?: components["schemas"]["AbiInput"][];
      internalType?: string;
    };
    AbiOutput: {
      name: string;
      type: string;
      components?: components["schemas"]["AbiOutput"][];
      internalType?: string;
    };
    /** @enum {string} */
    StateMutabilityType: "pure" | "view" | "nonpayable" | "payable";
    /** @enum {string} */
    AbiType: "function" | "constructor" | "event" | "fallback";
    AbiItem: {
      anonymous?: boolean;
      constant?: boolean;
      inputs?: components["schemas"]["AbiInput"][];
      name?: string;
      outputs?: components["schemas"]["AbiOutput"][];
      payable?: boolean;
      stateMutability?: components["schemas"]["StateMutabilityType"];
      type: components["schemas"]["AbiType"];
      /** Format: double */
      gas?: number;
    };
    IAbi: { [key: string]: components["schemas"]["AbiItem"] };
    IERC20Transfer: {
      transactionHash: string;
      tokenAddress: string;
      /** Format: double */
      logIndex: number;
      tag: string;
      from: string;
      to: string;
      amount: string;
      valueWithDecimals: string;
    };
    IERC20Approval: {
      transactionHash: string;
      tokenAddress: string;
      /** Format: double */
      logIndex: number;
      tag: string;
      owner: string;
      spender: string;
      value: string;
      valueWithDecimals: string;
    };
    INFTTransfer: {
      transactionHash: string;
      tokenAddress: string;
      /** Format: double */
      logIndex: number;
      tag: string;
      from: string;
      to: string;
      tokenId: string;
    };
    INFTApproval: {
      transactionHash: string;
      tokenAddress: string;
      /** Format: double */
      logIndex: number;
      tag: string;
      account: string;
      operator: string;
      approved: boolean;
    };
    "WebhookTypes.IWebhook": {
      erc20Transfers: components["schemas"]["IERC20Transfer"][];
      erc20Approvals: components["schemas"]["IERC20Approval"][];
      nftTransfers: components["schemas"]["INFTTransfer"][];
      nftApprovals: components["schemas"]["INFTApproval"][];
      block: components["schemas"]["WebhookBlock"];
      chainId: string;
      logs: components["schemas"]["Log"][];
      txs: components["schemas"]["Transaction"][];
      txsInternal: components["schemas"]["InternalTransaction"][];
      abis: components["schemas"]["IAbi"];
      /** Format: double */
      retries: number;
      confirmed: boolean;
    };
    HistoryModel: {
      id: string;
      date: string;
      payload: components["schemas"]["WebhookTypes.IWebhook"];
      errorMessage: string;
      webhookUrl: string;
    };
    HistoryResponse: {
      result: components["schemas"]["HistoryModel"][];
      cursor?: string;
    };
    /**
     * Format: uuid
     * @description Stringified UUIDv4.
     * See [RFC 4112](https://tools.ietf.org/html/rfc4122)
     */
    UUID: string;
    /** @enum {string} */
    SettingsRegion:
      | "us-east-1"
      | "us-west-2"
      | "eu-central-1"
      | "ap-southeast-1";
    SettingsModel: {
      /** @description The region from where all the webhooks will be posted for this project */
      region?: components["schemas"]["SettingsRegion"];
    };
    StatsModel: {
      /**
       * Format: double
       * @description The total amount of webhooks delivered across all streams
       */
      totalWebhooksDelivered: number;
      /**
       * Format: double
       * @description The total amount of failed webhooks across all streams
       */
      totalWebhooksFailed: number;
      /**
       * Format: double
       * @description The total amount of logs processed across all streams, this includes failed webhooks
       */
      totalLogsProcessed: number;
      /**
       * Format: double
       * @description The total amount of txs processed across all streams, this includes failed webhooks
       */
      totalTxsProcessed: number;
      /**
       * Format: double
       * @description The total amount of internal txs processed across all streams, this includes failed webhooks
       */
      totalTxsInternalProcessed: number;
    };
    /**
     * @description The stream status:
     * [active] The Stream is healthy and processing blocks
     * [paused] The Stream is paused and is not processing blocks
     * [error] The Stream has encountered an error and is not processing blocks
     * @enum {string}
     */
    StreamsStatus: "active" | "paused" | "error";
    /**
     * @description The abi to parse the log object of the contract
     * @example {}
     */
    StreamsAbi: { [key: string]: unknown };
    /**
     * @description The filter object, optional and only used if the type : log
     * https://v1docs.moralis.io/moralis-dapp/automatic-transaction-sync/smart-contract-events#event-filters
     * @example {}
     */
    StreamsFilter: { [key: string]: unknown };
    /**
     * @description The stream type:
     * [wallet] listen to all native transactions of the address and all logs where the address is involved in at least one of the topics
     * [contract] listens to all native transactions of the address and all logs produced by the contract address
     * @enum {string}
     */
    StreamsType: "wallet" | "contract";
    StreamsModel: {
      /** @description Webhook URL where moralis will send the POST request. */
      webhookUrl: string;
      /** @description A description for this stream */
      description: string;
      /** @description A user-provided tag that will be send along the webhook, the user can use this tag to identify the specific stream if multiple streams are present */
      tag: string;
      /** @description The token address of the contract, required if the type : log */
      tokenAddress?: string | null;
      /** @description The topic0 of the event in hex, required if the type : log */
      topic0?: string | null;
      /** @description Include or not native transactions defaults to false (only applied when type:contract) */
      includeNativeTxs?: boolean;
      abi?: components["schemas"]["StreamsAbi"] | null;
      filter?: components["schemas"]["StreamsFilter"] | null;
      /** @description The wallet address of the user, required if the type : tx */
      address?: string | null;
      /** @description The ids of the chains for this stream in hex Ex: ["0x1","0x38"] */
      chainIds: string[];
      /** @description The type of stream to create log or tx */
      type: components["schemas"]["StreamsType"];
      /** @description The unique uuid of the stream */
      id?: components["schemas"]["UUID"];
      /** @description The status of the stream. */
      status?: components["schemas"]["StreamsStatus"];
    };
    StreamsResponse: {
      /** @description Array of project Streams */
      result: components["schemas"]["StreamsModel"][];
      /** @description Cursor for fetching next page */
      cursor?: string;
      /**
       * Format: double
       * @description Total count of streams on the project
       */
      total: number;
    };
    StreamsModelCreate: {
      /** @description Webhook URL where moralis will send the POST request. */
      webhookUrl: string;
      /** @description A description for this stream */
      description: string;
      /** @description A user-provided tag that will be send along the webhook, the user can use this tag to identify the specific stream if multiple streams are present */
      tag: string;
      /** @description The token address of the contract, required if the type : log */
      tokenAddress?: string | null;
      /** @description The topic0 of the event in hex, required if the type : log */
      topic0?: string | null;
      /** @description Include or not native transactions defaults to false (only applied when type:contract) */
      includeNativeTxs?: boolean;
      abi?: components["schemas"]["StreamsAbi"] | null;
      filter?: components["schemas"]["StreamsFilter"] | null;
      /** @description The wallet address of the user, required if the type : tx */
      address?: string | null;
      /** @description The ids of the chains for this stream in hex Ex: ["0x1","0x38"] */
      chainIds: string[];
      /** @description The type of stream to create log or tx */
      type: components["schemas"]["StreamsType"];
    };
    StreamsStatusUpdate: {
      /** @description The status of the stream. */
      status: components["schemas"]["StreamsStatus"];
    };
  };
  responses: {};
  parameters: {};
  requestBodies: {};
  headers: {};
}

export interface operations {
  GetHistory: {
    parameters: {
      query: {
        limit: number;
        cursor?: string;
      };
    };
    responses: {
      /** Ok */
      200: {
        content: {
          "application/json": components["schemas"]["HistoryResponse"];
        };
      };
    };
  };
  /** Replay a specific history. */
  ReplayHistory: {
    parameters: {
      path: {
        /** The id of the history to replay */
        id: components["schemas"]["UUID"];
      };
    };
    responses: {
      /** Ok */
      200: {
        content: {
          "application/json": components["schemas"]["HistoryModel"];
        };
      };
    };
  };
  /** Get the settings for the current project based on the project api-key. */
  GetSettings: {
    parameters: {};
    responses: {
      /** Ok */
      200: {
        content: {
          "application/json": components["schemas"]["SettingsModel"];
        };
      };
    };
  };
  /** Set the settings for the current project based on the project api-key. */
  SetSettings: {
    parameters: {};
    responses: {
      /** No content */
      204: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SettingsModel"];
      };
    };
  };
  /** Get the stats for the current project based on the project api-key (Beta - This endpoint could be replaced or removed). */
  GetStats: {
    parameters: {};
    responses: {
      /** Ok */
      200: {
        content: {
          "application/json": components["schemas"]["StatsModel"];
        };
      };
    };
  };
  /** Get all the evm streams for the current project based on the project api-key. */
  GetStreams: {
    parameters: {
      query: {
        /** Limit response results max value 100 */
        limit: number;
        /** Cursor for fetching next page */
        cursor?: string;
      };
    };
    responses: {
      /** Ok */
      200: {
        content: {
          "application/json": components["schemas"]["StreamsResponse"];
        };
      };
    };
  };
  /** Creates a new evm stream. */
  CreateStream: {
    parameters: {};
    responses: {
      /** Ok */
      200: {
        content: {
          "application/json": components["schemas"]["StreamsModel"];
        };
      };
    };
    /** Provide a Stream Model */
    requestBody: {
      content: {
        "application/json": components["schemas"]["StreamsModelCreate"];
      };
    };
  };
  /** Get a specific evm stream. */
  GetStream: {
    parameters: {
      path: {
        /** The id of the stream to get */
        id: components["schemas"]["UUID"];
      };
    };
    responses: {
      /** Ok */
      200: {
        content: {
          "application/json": components["schemas"]["StreamsModel"];
        };
      };
    };
  };
  /** Updates a specific evm stream. */
  UpdateStream: {
    parameters: {
      path: {
        /** The id of the stream to update */
        id: components["schemas"]["UUID"];
      };
    };
    responses: {
      /** Ok */
      200: {
        content: {
          "application/json": components["schemas"]["StreamsModel"];
        };
      };
    };
    /** Provide a Stream Model */
    requestBody: {
      content: {
        "application/json": components["schemas"]["StreamsModelCreate"];
      };
    };
  };
  /** Delete a specific evm stream. */
  DeleteStream: {
    parameters: {
      path: {
        /** The id of the stream to delete */
        id: components["schemas"]["UUID"];
      };
    };
    responses: {
      /** Ok */
      200: {
        content: {
          "application/json": components["schemas"]["StreamsModel"];
        };
      };
    };
  };
  /** Updates the status of specific evm stream. */
  UpdateStreamStatus: {
    parameters: {
      path: {
        /** The id of the stream to update */
        id: components["schemas"]["UUID"];
      };
    };
    responses: {
      /** Ok */
      200: {
        content: {
          "application/json": components["schemas"]["StreamsModel"];
        };
      };
    };
    /** Provide a Stream Model */
    requestBody: {
      content: {
        "application/json": components["schemas"]["StreamsStatusUpdate"];
      };
    };
  };
}

export interface external {}
