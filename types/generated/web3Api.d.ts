/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/block/{block_number_or_hash}": {
    /** Gets the contents of a block by block hash */
    get: operations["getBlock"];
  };
  "/dateToBlock": {
    /** Gets the closest block of the provided date */
    get: operations["getDateToBlock"];
  };
  "/{address}/logs": {
    /** Gets the logs from an address */
    get: operations["getLogsByAddress"];
  };
  "/block/{block_number_or_hash}/nft/transfers": {
    /** Gets NFT transfers by block number or block hash */
    get: operations["getNFTTransfersByBlock"];
  };
  "/transaction/{transaction_hash}": {
    /** Gets the contents of a block transaction by hash */
    get: operations["getTransaction"];
  };
  "/{address}/events": {
    /** Gets events in descending order based on block number */
    post: operations["getContractEvents"];
  };
  "/{address}/function": {
    /** Runs a given function of a contract abi and returns readonly data */
    post: operations["runContractFunction"];
  };
  "/{address}": {
    /** Gets native transactions in descending order based on block number */
    get: operations["getTransactions"];
  };
  "/{address}/balance": {
    /** Gets native balance for a specific address */
    get: operations["getNativeBalance"];
  };
  "/{address}/erc20": {
    /** Gets token balances for a specific address */
    get: operations["getTokenBalances"];
  };
  "/{address}/erc20/transfers": {
    /** Gets ERC20 token transactions in descending order based on block number */
    get: operations["getTokenTransfers"];
  };
  "/{address}/nft": {
    /**
     * Gets NFTs owned by the given address
     * * The response will include status [SYNCED/SYNCING] based on the contracts being indexed.
     * * Use the token_address param to get results for a specific contract only
     * * Note results will include all indexed NFTs
     * * Any request which includes the token_address param will start the indexing process for that NFT collection the very first time it is requested
     */
    get: operations["getNFTs"];
  };
  "/{address}/nft/transfers": {
    /** Gets the transfers of the tokens matching the given parameters */
    get: operations["getNFTTransfers"];
  };
  "/{address}/nft/{token_address}": {
    /**
     * Gets NFTs owned by the given address
     * * Use the token_address param to get results for a specific contract only
     * * Note results will include all indexed NFTs
     * * Any request which includes the token_address param will start the indexing process for that NFT collection the very first time it is requested
     */
    get: operations["getNFTsForContract"];
  };
  "/erc20/metadata": {
    /** Returns metadata (name, symbol, decimals, logo) for a given token contract address. */
    get: operations["getTokenMetadata"];
  };
  "/nft/{address}/trades": {
    /** Get the nft trades for a given contracts and marketplace */
    get: operations["getNFTTrades"];
  };
  "/nft/{address}/lowestprice": {
    /** Get the lowest price found for a nft token contract for the last x days (only trades paid in ETH) */
    get: operations["getNFTLowestPrice"];
  };
  "/erc20/metadata/symbols": {
    /** Returns metadata (name, symbol, decimals, logo) for a given token contract address. */
    get: operations["getTokenMetadataBySymbol"];
  };
  "/erc20/{address}/price": {
    /** Returns the price nominated in the native token and usd for a given token contract address. */
    get: operations["getTokenPrice"];
  };
  "/erc20/{address}/transfers": {
    /** Gets ERC20 token contract transactions in descending order based on block number */
    get: operations["getTokenAddressTransfers"];
  };
  "/erc20/{address}/allowance": {
    /** Gets the amount which the spender is allowed to withdraw from the spender */
    get: operations["getTokenAllowance"];
  };
  "/nft/search": {
    /** Gets NFTs that match a given metadata search. */
    get: operations["searchNFTs"];
  };
  "/nft/transfers": {
    /** Gets the transfers of the tokens from a block number to a block number */
    get: operations["getNftTransfersFromToBlock"];
  };
  "/nft/{address}": {
    /**
     * Gets data, including metadata (where available), for all token ids for the given contract address.
     * * Results are limited to 100 per page by default
     * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     */
    get: operations["getAllTokenIds"];
  };
  "/nft/{address}/transfers": {
    /** Gets the transfers of the tokens matching the given parameters */
    get: operations["getContractNFTTransfers"];
  };
  "/nft/{address}/owners": {
    /**
     * Gets all owners of NFT items within a given contract collection
     * * Use after /nft/contract/{token_address} to find out who owns each token id in a collection
     * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     */
    get: operations["getNFTOwners"];
  };
  "/nft/{address}/metadata": {
    /**
     * Gets the contract level metadata (name, symbol, base token uri) for the given contract
     * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     */
    get: operations["getNFTMetadata"];
  };
  "/nft/{address}/{token_id}/metadata/resync": {
    /**
     * ReSync the metadata for an NFT
     * * The metadata flag will request a the NFT's metadata from the already existing token_uri
     * * The uri(default) flag will fetch the latest token_uri from the given NFT address. In sync mode the metadata will also be fetched
     * * The sync mode will make the endpoint synchronous so it will wait for the task to be completed before responding
     * * The async mode(default) will make the endpoint asynchronous so we will wait for the task to be completed before responding
     */
    get: operations["reSyncMetadata"];
  };
  "/nft/{address}/sync": {
    /** Sync a Contract for NFT Index */
    put: operations["syncNFTContract"];
  };
  "/nft/{address}/{token_id}": {
    /**
     * Gets data, including metadata (where available), for the given token id of the given contract address.
     * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     */
    get: operations["getTokenIdMetadata"];
  };
  "/nft/{address}/{token_id}/owners": {
    /**
     * Gets all owners of NFT items within a given contract collection
     * * Use after /nft/contract/{token_address} to find out who owns each token id in a collection
     * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     */
    get: operations["getTokenIdOwners"];
  };
  "/nft/{address}/{token_id}/transfers": {
    /** Gets the transfers of the tokens matching the given parameters */
    get: operations["getWalletTokenIdTransfers"];
  };
  "/resolve/{domain}": {
    /** Resolves an Unstoppable domain and returns the address */
    get: operations["resolveDomain"];
  };
  "/resolve/{address}/reverse": {
    /** Resolves an ETH address and find the ENS name */
    get: operations["resolveAddress"];
  };
  "/{pair_address}/reserves": {
    /** Get the liquidity reserves for a given pair address. Only Uniswap V2 based exchanges supported at the moment. */
    get: operations["getPairReserves"];
  };
  "/{token0_address}/{token1_address}/pairAddress": {
    /**
     * Fetches and returns pair data of the provided token0+token1 combination.
     * The token0 and token1 options are interchangable (ie. there is no different outcome in "token0=WETH and token1=USDT" or "token0=USDT and token1=WETH")
     */
    get: operations["getPairAddress"];
  };
  "/ipfs/uploadFolder": {
    /** Uploads multiple files and place them in a folder directory */
    post: operations["uploadFolder"];
  };
  "/web3/version": {
    get: operations["web3ApiVersion"];
  };
  "/info/endpointWeights": {
    get: operations["endpointWeights"];
  };
}

export interface components {
  schemas: {
    logCollection: {
      /**
       * @description The total number of matches for this query
       * @example 100
       */
      total?: number;
      /**
       * @description The page of the current result
       * @example 1
       */
      page?: number;
      /**
       * @description The number of results per page
       * @example 100
       */
      page_size?: number;
      /** @description The cursor to get to the next page */
      cursor?: string;
      result?: components["schemas"]["logEventByAddress"][];
    };
    logEventByAddress: {
      /**
       * @description The transaction hash
       * @example 0x2d30ca6f024dbc1307ac8a1a44ca27de6f797ec22ef20627a1307243b0ab7d09
       */
      transaction_hash: string;
      /**
       * @description The address of the contract
       * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
       */
      address: string;
      /**
       * @description The block timestamp
       * @example 2021-04-02T10:07:54.000Z
       */
      block_timestamp: string;
      /**
       * @description The block number
       * @example 12526958
       */
      block_number: string;
      /**
       * @description The block hash
       * @example 0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86
       */
      block_hash: string;
      /**
       * @description The data of the log
       * @example 0x00000000000000000000000000000000000000000000000de05239bccd4d537400000000000000000000000000024dbc80a9f80e3d5fc0a0ee30e2693781a443
       */
      data: string;
      /** @example 0x2caecd17d02f56fa897705dcc740da2d237c373f70686f4e0d9bd3bf0400ea7a */
      topic0: string;
      /** @example 0x000000000000000000000000031002d15b0d0cd7c9129d6f644446368deae391 */
      topic1: string;
      /** @example 0x000000000000000000000000d25943be09f968ba740e0782a34e710100defae9 */
      topic2: string;
      topic3: string;
    };
    logEvent: {
      /**
       * @description The transaction hash
       * @example 0x2d30ca6f024dbc1307ac8a1a44ca27de6f797ec22ef20627a1307243b0ab7d09
       */
      transaction_hash: string;
      /**
       * @description The address of the contract
       * @example 0x18F97EF6B2cbac5CA85b375b7093C4A207340d06
       */
      address: string;
      /**
       * @description The block timestamp
       * @example 2021-04-02T10:07:54.000Z
       */
      block_timestamp: string;
      /**
       * @description The block number
       * @example 12526958
       */
      block_number: string;
      /**
       * @description The block hash
       * @example 0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86
       */
      block_hash: string;
      /** @description The content of the event */
      data: {
        /** @example 0x54ff6974c715956a5049a123408bff91fbe29f01 */
        from?: string;
        /** @example 0x74de5d4fcbf63e00296fd95d33236b9794016631 */
        to?: string;
        /** @example 260103496340000000000 */
        value?: string;
      };
    };
    log: {
      /** @example 273 */
      log_index: string;
      /**
       * @description The hash of the transaction
       * @example 0xdd9006489e46670e0e85d1fb88823099e7f596b08aeaac023e9da0851f26fdd5
       */
      transaction_hash: string;
      /** @example 204 */
      transaction_index: string;
      /**
       * @description The address of the contract
       * @example 0x3105d328c66d8d55092358cf595d54608178e9b5
       */
      address: string;
      /**
       * @description The data of the log
       * @example 0x00000000000000000000000000000000000000000000000de05239bccd4d537400000000000000000000000000024dbc80a9f80e3d5fc0a0ee30e2693781a443
       */
      data: string;
      /** @example 0x2caecd17d02f56fa897705dcc740da2d237c373f70686f4e0d9bd3bf0400ea7a */
      topic0: string;
      /** @example 0x000000000000000000000000031002d15b0d0cd7c9129d6f644446368deae391 */
      topic1?: string;
      /** @example 0x000000000000000000000000d25943be09f968ba740e0782a34e710100defae9 */
      topic2?: string;
      topic3?: string;
      /**
       * @description The timestamp of the block
       * @example 2021-05-07T11:08:35.000Z
       */
      block_timestamp: string;
      /**
       * @description The block number
       * @example 12386788
       */
      block_number: string;
      /**
       * @description The hash of the block
       * @example 0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171
       */
      block_hash: string;
    };
    blockTransaction: {
      /**
       * @description The hash of the transaction
       * @example 0x1ed85b3757a6d31d01a4d6677fc52fd3911d649a0af21fe5ca3f886b153773ed
       */
      hash: string;
      /**
       * @description The nonce
       * @example 1848059
       */
      nonce: string;
      /** @example 108 */
      transaction_index: string;
      /**
       * @description The from address
       * @example 0x267be1c1d684f78cb4f6a176c4911b741e4ffdc0
       */
      from_address: string;
      /**
       * @description The to address
       * @example 0x003dde3494f30d861d063232c6a8c04394b686ff
       */
      to_address: string;
      /**
       * @description The value sent
       * @example 115580000000000000
       */
      value: string;
      /** @example 30000 */
      gas?: string;
      /**
       * @description The gas price
       * @example 52500000000
       */
      gas_price: string;
      /** @example 0x */
      input: string;
      /** @example 4923073 */
      receipt_cumulative_gas_used: string;
      /** @example 21000 */
      receipt_gas_used: string;
      receipt_contract_address?: string;
      receipt_root?: string;
      /** @example 1 */
      receipt_status: string;
      /**
       * @description The block timestamp
       * @example 2021-05-07T11:08:35.000Z
       */
      block_timestamp: string;
      /**
       * @description The block number
       * @example 12386788
       */
      block_number: string;
      /**
       * @description The hash of the block
       * @example 0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171
       */
      block_hash: string;
      /** @description The logs of the transaction */
      logs: components["schemas"]["log"][];
    };
    block: {
      /**
       * @description The block timestamp
       * @example 2021-05-07T11:08:35.000Z
       */
      timestamp: string;
      /**
       * @description The block number
       * @example 12386788
       */
      number: string;
      /**
       * @description The block hash
       * @example 0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171
       */
      hash: string;
      /**
       * @description The block hash of the parent block
       * @example 0x011d1fc45839de975cc55d758943f9f1d204f80a90eb631f3bf064b80d53e045
       */
      parent_hash: string;
      /**
       * @description The nonce
       * @example 0xedeb2d8fd2b2bdec
       */
      nonce: string;
      /** @example 0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347 */
      sha3_uncles: string;
      /** @example 0xdde5fc46c5d8bcbd58207bc9f267bf43298e23791a326ff02661e99790da9996b3e0dd912c0b8202d389d282c56e4d11eb2dec4898a32b6b165f1f4cae6aa0079498eab50293f3b8defbf6af11bb75f0408a563ddfc26a3323d1ff5f9849e95d5f034d88a757ddea032c75c00708c9ff34d2207f997cc7d93fd1fa160a6bfaf62a54e31f9fe67ab95752106ba9d185bfdc9b6dc3e17427f844ee74e5c09b17b83ad6e8fc7360f5c7c3e4e1939e77a6374bee57d1fa6b2322b11ad56ad0398302de9b26d6fbfe414aa416bff141fad9d4af6aea19322e47595e342cd377403f417dfd396ab5f151095a5535f51cbc34a40ce9648927b7d1d72ab9daf253e31daf */
      logs_bloom: string;
      /** @example 0xe4c7bf3aff7ad07f9e80d57f7189f0252592fee6321c2a9bd9b09b6ce0690d27 */
      transactions_root: string;
      /** @example 0x49e3bfe7b618e27fde8fa08884803a8458b502c6534af69873a3cc926a7c724b */
      state_root: string;
      /** @example 0x7cf43d7e837284f036cf92c56973f5e27bdd253ca46168fa195a6b07fa719f23 */
      receipts_root: string;
      /**
       * @description The address of the miner
       * @example 0xea674fdde714fd979de3edf0f56aa9716b898ec8
       */
      miner: string;
      /**
       * @description The difficulty of the block
       * @example 7253857437305950
       */
      difficulty: string;
      /**
       * @description The total difficulty
       * @example 24325637817906576196890
       */
      total_difficulty: string;
      /**
       * @description The block size
       * @example 61271
       */
      size: string;
      /** @example 0x65746865726d696e652d6575726f70652d7765737433 */
      extra_data: string;
      /**
       * @description The gas limit
       * @example 14977947
       */
      gas_limit: string;
      /**
       * @description The gas used
       * @example 14964688
       */
      gas_used: string;
      /**
       * @description The number of transactions in the block
       * @example 252
       */
      transaction_count: string;
      /** @description The transactions in the block */
      transactions: components["schemas"]["blockTransaction"][];
    };
    blockDate: {
      /**
       * @description The date of the block
       * @example 2020-01-01T00:00:00+00:00
       */
      date: string;
      /**
       * @description The blocknumber
       * @example 9193266
       */
      block: number;
      /**
       * @description The timestamp of the block
       * @example 1577836811
       */
      timestamp: number;
    };
    RunContractDto: {
      /**
       * @description The contract abi
       * @example
       */
      abi: { [key: string]: unknown };
      /**
       * @description The params for the given function
       * @example [object Object]
       */
      params?: { [key: string]: unknown };
    };
    transactionCollection: {
      /**
       * @description The total number of matches for this query
       * @example 2000
       */
      total?: number;
      /**
       * @description The page of the current result
       * @example 2
       */
      page?: number;
      /**
       * @description The number of results per page
       * @example 100
       */
      page_size?: number;
      result?: components["schemas"]["transaction"][];
    };
    transaction: {
      /**
       * @description The hash of the transaction
       * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
       */
      hash: string;
      /**
       * @description The nonce of the transaction
       * @example 326595425
       */
      nonce: string;
      /**
       * @description The transaction index
       * @example 25
       */
      transaction_index: string;
      /**
       * @description The sender
       * @example 0xd4a3BebD824189481FC45363602b83C9c7e9cbDf
       */
      from_address: string;
      /**
       * @description The recipient
       * @example 0xa71db868318f0a0bae9411347cd4a6fa23d8d4ef
       */
      to_address: string;
      /**
       * @description The value that was transfered (in wei)
       * @example 650000000000000000
       */
      value: string;
      /**
       * @description The gas of the transaction
       * @example 6721975
       */
      gas: string;
      /**
       * @description The gas price
       * @example 20000000000
       */
      gas_price: string;
      /** @description The input */
      input: string;
      /**
       * @description The receipt cumulative gas used
       * @example 1340925
       */
      receipt_cumulative_gas_used: string;
      /**
       * @description The receipt gas used
       * @example 1340925
       */
      receipt_gas_used: string;
      /**
       * @description The receipt contract address
       * @example 0x1d6a4cf64b52f6c73f201839aded7379ce58059c
       */
      receipt_contract_address: string;
      /** @description The receipt root */
      receipt_root: string;
      /**
       * @description The receipt status
       * @example 1
       */
      receipt_status: string;
      /**
       * @description The block timestamp
       * @example 2021-04-02T10:07:54.000Z
       */
      block_timestamp: string;
      /**
       * @description The block number
       * @example 12526958
       */
      block_number: string;
      /**
       * @description The block hash
       * @example 0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86
       */
      block_hash: string;
    };
    erc20Allowance: {
      /** @description The allowance */
      allowance: string;
    };
    erc20TokenBalance: {
      /**
       * @description The address of the token contract
       * @example 0x2d30ca6f024dbc1307ac8a1a44ca27de6f797ec22ef20627a1307243b0ab7d09
       */
      token_address: string;
      /**
       * @description The name of the token Contract
       * @example Kylin Network
       */
      name: string;
      /**
       * @description The symbol of the NFT contract
       * @example KYL
       */
      symbol: string;
      /**
       * @description The logo of the token
       * @example https://cdn.moralis.io/eth/0x67b6d479c7bb412c54e03dca8e1bc6740ce6b99c.png
       */
      logo?: string;
      /**
       * @description The thumbnail of the logo
       * @example https://cdn.moralis.io/eth/0x67b6d479c7bb412c54e03dca8e1bc6740ce6b99c_thumb.png
       */
      thumbnail?: string;
      /**
       * @description The number of decimals on of the token
       * @example 18
       */
      decimals: number;
      /**
       * @description Timestamp of when the contract was last synced with the node
       * @example 123456789
       */
      balance: string;
    };
    nativeBalance: {
      /**
       * @description The balance
       * @example 1234567890
       */
      balance: string;
    };
    trade: {
      /**
       * @description The transaction hash
       * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
       */
      transaction_hash: string;
      /** @description The transaction index */
      transaction_index: string;
      /**
       * @description The token id(s) traded
       * @example 15,54
       */
      token_ids: unknown[];
      /**
       * @description The address that sold the NFT
       * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
       */
      seller_address: string;
      /**
       * @description The address that bought the NFT
       * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
       */
      buyer_address: string;
      /**
       * @description The address of the contract that traded the NFT
       * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
       */
      marketplace_address: string;
      /**
       * @description The value that was sent in the transaction (ETH/BNB/etc..)
       * @example 1000000000000000
       */
      price: string;
      /**
       * @description The block timestamp
       * @example 2021-06-04T16:00:15
       */
      block_timestamp: string;
      /**
       * @description The blocknumber of the transaction
       * @example 13680123
       */
      block_number: string;
      /**
       * @description The block hash
       * @example 0x4a7c916ca4a970358b9df90051008f729685ff05e9724a9dddba32630c37cb96
       */
      block_hash: string;
    } & {
      token_address: unknown;
    };
    tradeCollection: {
      /**
       * @description The total number of matches for this query
       * @example 2000
       */
      total?: number;
      /**
       * @description The page of the current result
       * @example 2
       */
      page?: number;
      /**
       * @description The number of results per page
       * @example 100
       */
      page_size?: number;
      result?: components["schemas"]["trade"][];
    };
    /**
     * @default eth
     * @example eth
     */
    chainList:
      | "eth"
      | "0x1"
      | "ropsten"
      | "0x3"
      | "rinkeby"
      | "0x4"
      | "goerli"
      | "0x5"
      | "kovan"
      | "0x2a"
      | "polygon"
      | "0x89"
      | "mumbai"
      | "0x13881"
      | "bsc"
      | "0x38"
      | "bsc testnet"
      | "0x61"
      | "avalanche"
      | "0xa86a"
      | "avalanche testnet"
      | "0xa869"
      | "fantom"
      | "0xfa"
      | "cronos"
      | "0x19"
      | "cronos testnet"
      | "0x152";
    nft: {
      /**
       * @description The address of the contract of the NFT
       * @example 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB
       */
      token_address: string;
      /**
       * @description The token id of the NFT
       * @example 15
       */
      token_id: string;
      /**
       * @description The owner wallet address of the NFT
       * @example 0x9c83ff0f1c8924da96cb2fcb7e093f78eb2e316b
       */
      owner_of?: string;
      /**
       * @description The token hash
       * @example 502cee781b0fb40ea02508b21d319ced
       */
      token_hash?: string;
      /**
       * @description The block number when the amount or owner changed
       * @example 88256
       */
      block_number?: string;
      /**
       * @description The block number when the NFT was minted
       * @example 88256
       */
      block_number_minted?: string;
      /**
       * @description The type of NFT contract standard
       * @example ERC721
       */
      contract_type: string;
      /** @description The uri to the metadata of the token */
      token_uri?: string;
      /** @description The metadata of the token */
      metadata?: string;
      /** @description When the token_uri was last updated */
      last_token_uri_sync?: string;
      /** @description When the metadata was last updated */
      last_metadata_sync?: string;
      /**
       * @description The number of this item the user owns (used by ERC1155)
       * @example 1
       */
      amount?: string;
      /**
       * @description The name of the Token contract
       * @example CryptoKitties
       */
      name: string;
      /**
       * @description The symbol of the NFT contract
       * @example RARI
       */
      symbol: string;
    };
    nftMetadata: {
      /**
       * @description The token id of the NFT
       * @example 889
       */
      token_id: string;
      /**
       * @description The address of the contract of the NFT
       * @example 0x8ce66ff0865570d1ff0bb0098fa41b4dc61e02e6
       */
      token_address: string;
      /**
       * @description The uri to the metadata of the token
       * @example https://ipfs.moralis.io:2053/ipfs/QmZZbo8u8zEWg7wtmZhJS2W718WL6FA95T4XdgmCcLp1SJ/889.json
       */
      token_uri: string;
      /**
       * @description The metadata of the token
       * @example {"name":"Bape #889","description":"The #1 metavestor clan (NFT/DAO) by a team with multi billion dollar company experience.","image":"https://bapesclan.mypinata.cloud/ipfs/QmTSUD5JA6qHaC5t25mcXySfz19AV9u4Mb6Na7ntQ6tEwf/889.jpg","attributes":[{"trait_type":"Background","value":"Black"},{"trait_type":"Body","value":"Man"},{"trait_type":"Dress","value":"Suit Tie Blue"},{"trait_type":"Face","value":"Pipe"},{"trait_type":"Eye","value":"Eye"}]}
       */
      metadata: string;
      /** @example 1 */
      is_valid: number;
      /** @example 2 */
      syncing: number;
      /** @example 0 */
      frozen: number;
      /** @example 0 */
      resyncing: number;
      /**
       * @description The type of NFT contract standard
       * @example ERC721
       */
      contract_type: string;
      /** @example fffa3102469ce77f569893d16d5884f9 */
      token_hash: string;
      /** @example fd995c8a-f8b2-40cb-a407-f43e552638b4 */
      batch_id: string;
      /** @example Bape #889 */
      metadata_name: string;
      /** @example The #1 metavestor clan (NFT/DAO) by a team with multi billion dollar company experience. */
      metadata_description: string;
      /** @example [{"trait_type":"Background","value":"Black"},{"trait_type":"Body","value":"Man"},{"trait_type":"Dress","value":"Suit Tie Blue"},{"trait_type":"Face","value":"Pipe"},{"trait_type":"Eye","value":"Eye"}] */
      metadata_attributes: string;
      /** @example 14265936 */
      block_number_minted: string;
      opensea_lookup?: { [key: string]: unknown };
      /** @example 0xdcf086e3f7954b38180daae1405569da86588bfe */
      minter_address: string;
      /** @example 0x2c8d7ec7a8439b0f67b50e93be63242de52e9b5cdfc7dc0aee80c6a2f104c41a */
      transaction_minted: string;
      frozen_log_index?: { [key: string]: unknown };
      imported?: { [key: string]: unknown };
      /**
       * @description When the token_uri was last updated
       * @example 2021-02-24T00:47:26.647Z
       */
      last_token_uri_sync: string;
      /**
       * @description When the metadata was last updated
       * @example 2021-02-24T00:47:26.647Z
       */
      last_metadata_sync: string;
      /**
       * Format: date-time
       * @example 2022-02-24T00:47:26.647Z
       */
      createdAt: string;
      /**
       * Format: date-time
       * @example 2022-04-09T23:56:44.807Z
       */
      updatedAt: string;
    };
    nftCollection: {
      /**
       * @description The total number of matches for this query
       * @example 2000
       */
      total?: number;
      /**
       * @description The page of the current result
       * @example 2
       */
      page?: number;
      /**
       * @description The number of results per page
       * @example 100
       */
      page_size?: number;
      /** @description The cursor to get to the next page */
      cursor?: string;
      result?: components["schemas"]["nft"][];
    };
    nftMetadataCollection: {
      /**
       * @description The total number of matches for this query
       * @example 2000
       */
      total?: number;
      /**
       * @description The page of the current result
       * @example 2
       */
      page?: number;
      /**
       * @description The number of results per page
       * @example 100
       */
      page_size?: number;
      result?: components["schemas"]["nftMetadata"][];
    };
    nftOwner: {
      /**
       * @description The address of the contract of the NFT
       * @example 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB
       */
      token_address: string;
      /**
       * @description The token id of the NFT
       * @example 15
       */
      token_id: string;
      /**
       * @description The type of NFT contract standard
       * @example ERC721
       */
      contract_type: string;
      /**
       * @description The address of the owner of the NFT
       * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
       */
      owner_of: string;
      /**
       * @description The blocknumber when the amount or owner changed
       * @example 88256
       */
      block_number: string;
      /**
       * @description The blocknumber when the NFT was minted
       * @example 88256
       */
      block_number_minted: string;
      /** @description The uri to the metadata of the token */
      token_uri?: string;
      /** @description The metadata of the token */
      metadata?: string;
      /**
       * @description The number of this item the user owns (used by ERC1155)
       * @example 1
       */
      amount?: string;
      /**
       * @description The name of the Token contract
       * @example CryptoKitties
       */
      name: string;
      /**
       * @description The symbol of the NFT contract
       * @example RARI
       */
      symbol: string;
      /**
       * @description The token hash
       * @example 502cee781b0fb40ea02508b21d319ced
       */
      token_hash: string;
      /**
       * @description When the token_uri was last updated
       * @example 2021-02-24T00:47:26.647Z
       */
      last_token_uri_sync: string;
      /**
       * @description When the metadata was last updated
       * @example 2021-02-24T00:47:26.647Z
       */
      last_metadata_sync: string;
    };
    nftOwnerCollection: {
      /**
       * @description The syncing status of the address [SYNCING/SYNCED]
       * @example SYNCING
       */
      status?: string;
      /**
       * @description The total number of matches for this query
       * @example 2000
       */
      total?: number;
      /**
       * @description The page of the current result
       * @example 2
       */
      page?: number;
      /**
       * @description The number of results per page
       * @example 100
       */
      page_size?: number;
      /** @description The cursor to get to the next page */
      cursor?: string;
      result?: components["schemas"]["nftOwner"][];
    };
    nftTransfer: {
      /**
       * @description The address of the contract of the NFT
       * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
       */
      token_address: string;
      /**
       * @description The token id of the NFT
       * @example 15
       */
      token_id: string;
      /**
       * @description The address that sent the NFT
       * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
       */
      from_address?: string;
      /**
       * @description The address that recieved the NFT
       * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
       */
      to_address: string;
      /**
       * @description The value that was sent in the transaction (ETH/BNB/etc..)
       * @example 1000000000000000
       */
      value?: string;
      /**
       * @description The number of tokens transferred
       * @example 1
       */
      amount?: string;
      /**
       * @description The type of NFT contract standard
       * @example ERC721
       */
      contract_type: string;
      /**
       * @description The blocknumber of the transaction
       * @example 88256
       */
      block_number: string;
      /**
       * @description The block timestamp
       * @example 2021-06-04T16:00:15
       */
      block_timestamp: string;
      /** @description The block hash of the transaction */
      block_hash: string;
      /**
       * @description The transaction hash
       * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
       */
      transaction_hash: string;
      /** @description The transaction type */
      transaction_type?: string;
      /** @description The transaction index */
      transaction_index?: string;
      /** @description The log index */
      log_index: number;
      /**
       * @description The operator present only for ERC1155 Transfers
       * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
       */
      operator?: string;
    };
    nftTransferCollection: {
      /**
       * @description The total number of matches for this query
       * @example 2000
       */
      total: number;
      /**
       * @description The page of the current result
       * @example 2
       */
      page: number;
      /**
       * @description The number of results per page
       * @example 100
       */
      page_size: number;
      /** @description The cursor to get to the next page */
      cursor: string;
      result: components["schemas"]["nftTransfer"][];
      /**
       * @description Indicator if the block exists
       * @example true
       */
      block_exists?: boolean;
      /**
       * @description Indicator if the block is fully indexed
       * @example true
       */
      index_complete?: boolean;
    };
    nftContractMetadata: {
      /**
       * @description The address of the token contract
       * @example 0x2d30ca6f024dbc1307ac8a1a44ca27de6f797ec22ef20627a1307243b0ab7d09
       */
      token_address: string;
      /**
       * @description The name of the token Contract
       * @example KryptoKitties
       */
      name: string;
      /** @description Timestamp of when the contract was last synced with the node */
      synced_at?: string;
      /**
       * @description The symbol of the NFT contract
       * @example RARI
       */
      symbol: string;
      /**
       * @description The type of NFT contract
       * @example ERC721
       */
      contract_type: string;
    };
    nftContractMetadataCollection: {
      /**
       * @description The total number of matches for this query
       * @example 2000
       */
      total: number;
      /**
       * @description The page of the current result
       * @example 2
       */
      page: number;
      /**
       * @description The number of results per page
       * @example 100
       */
      page_size: number;
      result: components["schemas"]["nftContractMetadata"][];
    };
    erc20Transaction: {
      /**
       * @description The transaction hash
       * @example 0x2d30ca6f024dbc1307ac8a1a44ca27de6f797ec22ef20627a1307243b0ab7d09
       */
      transaction_hash: string;
      /**
       * @description The address of the token
       * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
       */
      address: string;
      /**
       * @description The block timestamp
       * @example 2021-04-02T10:07:54.000Z
       */
      block_timestamp: string;
      /**
       * @description The block number
       * @example 12526958
       */
      block_number: string;
      /**
       * @description The block hash
       * @example 0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86
       */
      block_hash: string;
      /**
       * @description The recipient
       * @example 0x62AED87d21Ad0F3cdE4D147Fdcc9245401Af0044
       */
      to_address: string;
      /**
       * @description The sender
       * @example 0xd4a3BebD824189481FC45363602b83C9c7e9cbDf
       */
      from_address: string;
      /**
       * @description The value that was transfered (in wei)
       * @example 650000000000000000
       */
      value: string;
    };
    historicalNftTransfer: {
      /**
       * @description The transaction hash
       * @example 0x2d30ca6f024dbc1307ac8a1a44ca27de6f797ec22ef20627a1307243b0ab7d09
       */
      transaction_hash: string;
      /**
       * @description The address of the token
       * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
       */
      address: string;
      /**
       * @description The block timestamp
       * @example 2021-04-02T10:07:54.000Z
       */
      block_timestamp: string;
      /**
       * @description The block number
       * @example 12526958
       */
      block_number: string;
      /**
       * @description The block hash
       * @example 0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86
       */
      block_hash: string;
      /**
       * @description The recipient
       * @example 0x62AED87d21Ad0F3cdE4D147Fdcc9245401Af0044
       */
      to_address: string;
      /**
       * @description The sender
       * @example 0xd4a3BebD824189481FC45363602b83C9c7e9cbDf
       */
      from_address: string;
      /** @description The token ids of the tokens that were transfered */
      token_ids: string[];
      /** @description The amounts that were transfered */
      amounts: string[];
      /**
       * @description They contract type of the transfer
       * @example ERC721
       */
      contract_type: string;
    };
    erc20Metadata: {
      /**
       * @description The address of the token contract
       * @example 0x2d30ca6f024dbc1307ac8a1a44ca27de6f797ec22ef20627a1307243b0ab7d09
       */
      address: string;
      /**
       * @description The name of the token Contract
       * @example Kylin Network
       */
      name: string;
      /**
       * @description The symbol of the NFT contract
       * @example KYL
       */
      symbol: string;
      /**
       * @description The number of decimals on of the token
       * @example 18
       */
      decimals: string;
      /**
       * @description The logo of the token
       * @example https://cdn.moralis.io/eth/0x67b6d479c7bb412c54e03dca8e1bc6740ce6b99c.png
       */
      logo?: string;
      /**
       * @description The logo hash
       * @example ee7aa2cdf100649a3521a082116258e862e6971261a39b5cd4e4354fcccbc54d
       */
      logo_hash?: string;
      /**
       * @description The thumbnail of the logo
       * @example https://cdn.moralis.io/eth/0x67b6d479c7bb412c54e03dca8e1bc6740ce6b99c_thumb.png
       */
      thumbnail?: string;
      block_number?: string;
      validated?: string;
    };
    metadataResync: {
      /** @description The status of resync request */
      status: string;
    };
    erc721Metadata: {
      /**
       * @description The name of the token Contract
       * @example Kylin Network
       */
      name: string;
      /**
       * @description The symbol of the NFT contract
       * @example KYL
       */
      symbol: string;
      token_uri?: string;
    };
    erc20Price: {
      nativePrice?: components["schemas"]["nativeErc20Price"];
      /**
       * Format: double
       * @description The price in USD for the token
       * @example 19.722370676
       */
      usdPrice: number;
      /**
       * @description The address of the exchange used to calculate the price
       * @example 0x1f98431c8ad98523631ae4a59f267346ea31f984
       */
      exchangeAddress?: string;
      /**
       * @description The name of the exchange used for calculating the price
       * @example Uniswap v3
       */
      exchangeName?: string;
    } & {
      symbol: unknown;
    };
    nativeErc20Price: {
      /**
       * @description The native price of the token
       * @example 8409770570506626
       */
      value: string;
      /**
       * @description The number of decimals of the token
       * @example 18
       */
      decimals: number;
      /**
       * @description The Name of the token
       * @example Ether
       */
      name: string;
      /**
       * @description The Symbol of the token
       * @example ETH
       */
      symbol: string;
    };
    erc20TransactionCollection: {
      /**
       * @description The total number of matches for this query
       * @example 2000
       */
      total?: number;
      /**
       * @description The page of the current result
       * @example 2
       */
      page?: number;
      /**
       * @description The number of results per page
       * @example 100
       */
      page_size?: number;
      result?: components["schemas"]["erc20Transaction"][];
    };
    ens: {
      /**
       * @description Resolved ENS address
       * @example Vitalik.eth
       */
      name: string;
    };
    resolve: {
      /**
       * @description Resolved domain address
       * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
       */
      address: string;
    };
    reservesCollection: {
      token0?: {
        /** @example 0x2b591e99afe9f32eaa6214f7b7629768c40eeb39 */
        address?: string;
        /** @example HEX */
        name?: string;
        /** @example HEX */
        symbol?: string;
        /** @example 9 */
        decimals?: string;
        /** @example https://cdn.moralis.io/eth/0x2b591e99afe9f32eaa6214f7b7629768c40eeb39.png */
        logo?: string;
        /** @example b3bd1b5512965d7b6aeee903dcc6d28b116d58c788eb41e9c1690baed878beaa */
        logo_hash?: string;
        /** @example https://cdn.moralis.io/eth/0x2b591e99afe9f32eaa6214f7b7629768c40eeb39_thumb.png */
        thumbnail?: string;
        /** @example 14836562 */
        block_number?: string;
        validated?: number;
        /** @example 2022-01-20T09:39:55.818Z */
        created_at?: string;
      };
      token1?: {
        /** @example 0xdac17f958d2ee523a2206206994597c13d831ec7 */
        address?: string;
        /** @example Tether USD */
        name?: string;
        /** @example USDT */
        symbol?: string;
        /** @example 6 */
        decimals?: string;
        /** @example https://cdn.moralis.io/eth/0xdac17f958d2ee523a2206206994597c13d831ec7.png */
        logo?: string;
        /** @example ee7aa2cdf100649a3521a082116258e862e6971261a39b5cd4e4354fcccbc54d */
        logo_hash?: string;
        /** @example https://cdn.moralis.io/eth/0xdac17f958d2ee523a2206206994597c13d831ec7_thumb.png */
        thumbnail?: string;
        /** @example 4638568 */
        block_number?: string;
        /** @example 1 */
        validated?: number;
        /** @example 2022-01-20T09:39:55.818Z */
        created_at?: string;
      };
      /** @example 0xbbb9bf440d0f686487925fef3b0a0f9aa67753f6 */
      pairAddress?: string;
    };
    ipfsFileRequest: {
      /**
       * @description Path to file
       * @example moralis/logo.jpg
       */
      path: string;
      /**
       * @description base64 or JSON
       * @example iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3
       */
      content: string;
    };
    ipfsFile: {
      /**
       * @description Path to file
       * @example https://ipfs.moralis.io/QmPQ3YJ3hgfsBzJ1U4MGyV2C1GhDy6MWCENr1qMdMpKVnY/moralis/logo.jpg
       */
      path: string;
    };
    web3version: {
      /**
       * @description version of the api
       * @example 1.0.0
       */
      version: string;
    };
    endpointWeights: {
      /**
       * @description endpoint
       * @example endpointWeights
       */
      endpoint: string;
      /**
       * @description The path to the endpoint
       * @example /info/endpointWeights
       */
      path: string;
      /**
       * @description The number of hits the requests counts for ratelimiting
       * @example 1
       */
      rateLimitWeight: string;
      /** @description The number of hits the requests counts for billing */
      price: string;
    };
  };
}

export interface operations {
  /** Gets the contents of a block by block hash */
  getBlock: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The subdomain of the moralis server to use (Only use when selecting local devchain as chain) */
        subdomain?: string;
      };
      path: {
        /** The block hash or block number */
        block_number_or_hash: string;
      };
    };
    responses: {
      /** Returns the contents of a block */
      200: {
        content: {
          "application/json": components["schemas"]["block"];
        };
      };
    };
  };
  /** Gets the closest block of the provided date */
  getDateToBlock: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** web3 provider url to user when using local dev chain */
        providerUrl?: string;
        /** Unix date in miliseconds or a datestring (any format that is accepted by momentjs) */
        date: string;
      };
    };
    responses: {
      /** Returns the blocknumber and corresponding date and timestamp */
      200: {
        content: {
          "application/json": components["schemas"]["blockDate"];
        };
      };
    };
  };
  /** Gets the logs from an address */
  getLogsByAddress: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The subdomain of the moralis server to use (Only use when selecting local devchain as chain) */
        subdomain?: string;
        /**
         * The block number
         * * Provide the param 'block_numer' or ('from_block' and / or 'to_block')
         * * If 'block_numer' is provided in conbinaison with 'from_block' and / or 'to_block', 'block_number' will will be used
         */
        block_number?: string;
        /**
         * The minimum block number from where to get the logs
         * * Provide the param 'block_numer' or ('from_block' and / or 'to_block')
         * * If 'block_numer' is provided in conbinaison with 'from_block' and / or 'to_block', 'block_number' will will be used
         */
        from_block?: string;
        /**
         * The maximum block number from where to get the logs
         * * Provide the param 'block_numer' or ('from_block' and / or 'to_block')
         * * If 'block_numer' is provided in conbinaison with 'from_block' and / or 'to_block', 'block_number' will will be used
         */
        to_block?: string;
        /**
         * The date from where to get the logs (any format that is accepted by momentjs)
         * * Provide the param 'from_block' or 'from_date'
         * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
         * * If 'from_date' and the block params are provided, the block params will be used. Please refer to the blocks params sections (block_number,from_block and to_block) on how to use them
         */
        from_date?: string;
        /**
         * Get the logs to this date (any format that is accepted by momentjs)
         * * Provide the param 'to_block' or 'to_date'
         * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
         * * If 'to_date' and the block params are provided, the block params will be used. Please refer to the blocks params sections (block_number,from_block and to_block) on how to use them
         */
        to_date?: string;
        /** topic0 */
        topic0?: string;
        /** topic1 */
        topic1?: string;
        /** topic2 */
        topic2?: string;
        /** topic3 */
        topic3?: string;
        /** limit */
        limit?: number;
        /** The cursor returned in the last response (for getting the next page) */
        cursor?: string;
      };
      path: {
        /** address */
        address: string;
      };
    };
    responses: {
      /** Returns the logs of an address */
      200: {
        content: {
          "application/json": components["schemas"]["logCollection"];
        };
      };
    };
  };
  /** Gets NFT transfers by block number or block hash */
  getNFTTransfersByBlock: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The subdomain of the moralis server to use (Only use when selecting local devchain as chain) */
        subdomain?: string;
        /** limit */
        limit?: number;
        /** The cursor returned in the last response (for getting the next page) */
        cursor?: string;
      };
      path: {
        /** The block hash or block number */
        block_number_or_hash: string;
      };
    };
    responses: {
      /** Returns the contents of a block */
      200: {
        content: {
          "application/json": components["schemas"]["nftTransferCollection"];
        };
      };
    };
  };
  /** Gets the contents of a block transaction by hash */
  getTransaction: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The subdomain of the moralis server to use (Only use when selecting local devchain as chain) */
        subdomain?: string;
      };
      path: {
        /** The transaction hash */
        transaction_hash: string;
      };
    };
    responses: {
      /** Transaction details by transaction hash */
      200: {
        content: {
          "application/json": components["schemas"]["blockTransaction"];
        };
      };
    };
  };
  /** Gets events in descending order based on block number */
  getContractEvents: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The subdomain of the moralis server to use (Only use when selecting local devchain as chain) */
        subdomain?: string;
        /** web3 provider url to user when using local dev chain */
        providerUrl?: string;
        /**
         * The minimum block number from where to get the logs
         * * Provide the param 'from_block' or 'from_date'
         * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
         */
        from_block?: number;
        /**
         * The maximum block number from where to get the logs.
         * * Provide the param 'to_block' or 'to_date'
         * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
         */
        to_block?: number;
        /**
         * The date from where to get the logs (any format that is accepted by momentjs)
         * * Provide the param 'from_block' or 'from_date'
         * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
         */
        from_date?: string;
        /**
         * Get the logs to this date (any format that is accepted by momentjs)
         * * Provide the param 'to_block' or 'to_date'
         * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
         */
        to_date?: string;
        /** The topic of the event */
        topic: string;
        /** offset */
        offset?: number;
        /** limit */
        limit?: number;
      };
      path: {
        /** address */
        address: string;
      };
    };
    responses: {
      /** Returns a collection of events by topic */
      200: {
        content: {
          "application/json": {
            /**
             * @description The total number of matches for this query
             * @example 2000
             */
            total?: number;
            /**
             * @description The page of the current result
             * @example 2
             */
            page?: number;
            /**
             * @description The number of results per page
             * @example 100
             */
            page_size?: number;
            result?: components["schemas"]["logEvent"][];
          };
        };
      };
    };
    /** ABI of the specific event */
    requestBody: {
      content: {
        "application/json": { [key: string]: unknown };
      };
    };
  };
  /** Runs a given function of a contract abi and returns readonly data */
  runContractFunction: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The subdomain of the moralis server to use (Only use when selecting local devchain as chain) */
        subdomain?: string;
        /** web3 provider url to user when using local dev chain */
        providerUrl?: string;
        /** function_name */
        function_name: string;
      };
      path: {
        /** address */
        address: string;
      };
    };
    responses: {
      /** Returns response of the function executed */
      200: {
        content: {
          "application/json": string;
        };
      };
    };
    /** Body */
    requestBody: {
      content: {
        "application/json": components["schemas"]["RunContractDto"];
      };
    };
  };
  /** Gets native transactions in descending order based on block number */
  getTransactions: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The subdomain of the moralis server to use (Only use when selecting local devchain as chain) */
        subdomain?: string;
        /**
         * The minimum block number from where to get the transactions
         * * Provide the param 'from_block' or 'from_date'
         * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
         */
        from_block?: number;
        /**
         * The maximum block number from where to get the transactions.
         * * Provide the param 'to_block' or 'to_date'
         * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
         */
        to_block?: number;
        /**
         * The date from where to get the transactions (any format that is accepted by momentjs)
         * * Provide the param 'from_block' or 'from_date'
         * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
         */
        from_date?: string;
        /**
         * Get the transactions to this date (any format that is accepted by momentjs)
         * * Provide the param 'to_block' or 'to_date'
         * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
         */
        to_date?: string;
        /** The cursor returned in the last response (for getting the next page) */
        cursor?: unknown;
        /** limit */
        limit?: number;
      };
      path: {
        /** address */
        address: string;
      };
    };
    responses: {
      /** Returns a collection of native transactions. */
      200: {
        content: {
          "application/json": components["schemas"]["transactionCollection"];
        };
      };
    };
  };
  /** Gets native balance for a specific address */
  getNativeBalance: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** web3 provider url to user when using local dev chain */
        providerUrl?: string;
        /** The block number on which the balances should be checked */
        to_block?: number;
      };
      path: {
        /** The address for which the native balance will be checked */
        address: string;
      };
    };
    responses: {
      /** Returns native balance for a specific address */
      200: {
        content: {
          "application/json": components["schemas"]["nativeBalance"];
        };
      };
    };
  };
  /** Gets token balances for a specific address */
  getTokenBalances: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The subdomain of the moralis server to use (Only use when selecting local devchain as chain) */
        subdomain?: string;
        /** The block number on which the balances should be checked */
        to_block?: number;
        /** The addresses to get balances for (Optional) */
        token_addresses?: string[];
      };
      path: {
        /** The address for which token balances will be checked */
        address: string;
      };
    };
    responses: {
      /** Returns token balances for a specific address */
      200: {
        content: {
          "application/json": components["schemas"]["erc20TokenBalance"][];
        };
      };
    };
  };
  /** Gets ERC20 token transactions in descending order based on block number */
  getTokenTransfers: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The subdomain of the moralis server to use (Only use when selecting local devchain as chain) */
        subdomain?: string;
        /**
         * The minimum block number from where to get the transactions
         * * Provide the param 'from_block' or 'from_date'
         * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
         */
        from_block?: number;
        /**
         * The maximum block number from where to get the transactions.
         * * Provide the param 'to_block' or 'to_date'
         * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
         */
        to_block?: number;
        /**
         * The date from where to get the transactions (any format that is accepted by momentjs)
         * * Provide the param 'from_block' or 'from_date'
         * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
         */
        from_date?: string;
        /**
         * Get the transactions to this date (any format that is accepted by momentjs)
         * * Provide the param 'to_block' or 'to_date'
         * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
         */
        to_date?: string;
        /** limit */
        limit?: number;
        /** The cursor returned in the last response (for getting the next page) */
        cursor?: string;
      };
      path: {
        /** address */
        address: string;
      };
    };
    responses: {
      /** Returns a collection of token transactions. */
      200: {
        content: {
          "application/json": components["schemas"]["erc20TransactionCollection"];
        };
      };
    };
  };
  /**
   * Gets NFTs owned by the given address
   * * The response will include status [SYNCED/SYNCING] based on the contracts being indexed.
   * * Use the token_address param to get results for a specific contract only
   * * Note results will include all indexed NFTs
   * * Any request which includes the token_address param will start the indexing process for that NFT collection the very first time it is requested
   */
  getNFTs: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The format of the token id */
        format?: "decimal" | "hex";
        /** limit */
        limit?: number;
        /** The addresses to get balances for (Optional) */
        token_addresses?: string[];
        /** The cursor returned in the last response (for getting the next page) */
        cursor?: string;
      };
      path: {
        /** The owner of a given token */
        address: string;
      };
    };
    responses: {
      /** Returns a collection of nft owners */
      200: {
        content: {
          "application/json": components["schemas"]["nftOwnerCollection"];
        };
      };
    };
  };
  /** Gets the transfers of the tokens matching the given parameters */
  getNFTTransfers: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The format of the token id */
        format?: "decimal" | "hex";
        /** The transfer direction */
        direction?: "both" | "to" | "from";
        /**
         * The minimum block number from where to get the transfers
         * * Provide the param 'from_block' or 'from_date'
         * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
         */
        from_block?: number;
        /** To get the reserves at this block number */
        to_block?: string;
        /** limit */
        limit?: number;
        /** The cursor returned in the last response (for getting the next page) */
        cursor?: string;
      };
      path: {
        /** The sender or recepient of the transfer */
        address: string;
      };
    };
    responses: {
      /** Returns a collection of NFT transfer */
      200: {
        content: {
          "application/json": components["schemas"]["nftTransferCollection"];
        };
      };
    };
  };
  /**
   * Gets NFTs owned by the given address
   * * Use the token_address param to get results for a specific contract only
   * * Note results will include all indexed NFTs
   * * Any request which includes the token_address param will start the indexing process for that NFT collection the very first time it is requested
   */
  getNFTsForContract: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The format of the token id */
        format?: "decimal" | "hex";
        /** The cursor returned in the last response (for getting the next page) */
        cursor?: string;
        /** limit */
        limit?: number;
      };
      path: {
        /** The owner of a given token */
        address: string;
        /** Address of the contract */
        token_address: string;
      };
    };
    responses: {
      /** Returns a collection of nft owners */
      200: {
        content: {
          "application/json": components["schemas"]["nftOwnerCollection"];
        };
      };
    };
  };
  /** Returns metadata (name, symbol, decimals, logo) for a given token contract address. */
  getTokenMetadata: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The subdomain of the moralis server to use (Only use when selecting local devchain as chain) */
        subdomain?: string;
        /** web3 provider url to user when using local dev chain */
        providerUrl?: string;
        /** The addresses to get metadata for */
        addresses: string[];
      };
    };
    responses: {
      /** Returns metadata (name, symbol, decimals, logo) for a given token contract address. */
      200: {
        content: {
          "application/json": components["schemas"]["erc20Metadata"][];
        };
      };
    };
  };
  /** Get the nft trades for a given contracts and marketplace */
  getNFTTrades: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /**
         * The minimum block number from where to get the transfers
         * * Provide the param 'from_block' or 'from_date'
         * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
         */
        from_block?: number;
        /** To get the reserves at this block number */
        to_block?: string;
        /**
         * The date from where to get the transfers (any format that is accepted by momentjs)
         * * Provide the param 'from_block' or 'from_date'
         * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
         */
        from_date?: string;
        /**
         * Get the reserves to this date (any format that is accepted by momentjs)
         * * Provide the param 'to_block' or 'to_date'
         * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
         */
        to_date?: string;
        /** web3 provider url to user when using local dev chain */
        provider_url?: string;
        /** marketplace from where to get the trades (only opensea is supported at the moment) */
        marketplace?: "opensea";
        /** cursor */
        cursor?: string;
        /** limit */
        limit?: number;
      };
      path: {
        /** Address of the contract */
        address: string;
      };
    };
    responses: {
      /** Returns the trades */
      200: {
        content: {
          "application/json": components["schemas"]["tradeCollection"];
        };
      };
    };
  };
  /** Get the lowest price found for a nft token contract for the last x days (only trades paid in ETH) */
  getNFTLowestPrice: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /**
         * The number of days to look back to find the lowest price
         * If not provided 7 days will be the default
         */
        days?: number;
        /** web3 provider url to user when using local dev chain */
        provider_url?: string;
        /** marketplace from where to get the trades (only opensea is supported at the moment) */
        marketplace?: "opensea";
      };
      path: {
        /** Address of the contract */
        address: string;
      };
    };
    responses: {
      /** Returns the trade with the lowest price */
      200: {
        content: {
          "application/json": components["schemas"]["trade"];
        };
      };
    };
  };
  /** Returns metadata (name, symbol, decimals, logo) for a given token contract address. */
  getTokenMetadataBySymbol: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The subdomain of the moralis server to use (Only use when selecting local devchain as chain) */
        subdomain?: string;
        /** The symbols to get metadata for */
        symbols: string[];
      };
    };
    responses: {
      /** Returns metadata (name, symbol, decimals, logo) for a given token contract address. */
      200: {
        content: {
          "application/json": components["schemas"]["erc20Metadata"][];
        };
      };
    };
  };
  /** Returns the price nominated in the native token and usd for a given token contract address. */
  getTokenPrice: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** web3 provider url to user when using local dev chain */
        providerUrl?: string;
        /** The factory name or address of the token exchange */
        exchange?: string;
        /** to_block */
        to_block?: number;
      };
      path: {
        /** The address of the token contract */
        address: string;
      };
    };
    responses: {
      /** Returns the price nominated in the native token and usd for a given token contract address */
      200: {
        content: {
          "application/json": components["schemas"]["erc20Price"];
        };
      };
    };
  };
  /** Gets ERC20 token contract transactions in descending order based on block number */
  getTokenAddressTransfers: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The subdomain of the moralis server to use (Only use when selecting local devchain as chain) */
        subdomain?: string;
        /**
         * The minimum block number from where to get the transfers
         * * Provide the param 'from_block' or 'from_date'
         * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
         */
        from_block?: number;
        /**
         * The maximum block number from where to get the transfers.
         * * Provide the param 'to_block' or 'to_date'
         * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
         */
        to_block?: number;
        /**
         * The date from where to get the transfers (any format that is accepted by momentjs)
         * * Provide the param 'from_block' or 'from_date'
         * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
         */
        from_date?: string;
        /**
         * Get the transfers to this date (any format that is accepted by momentjs)
         * * Provide the param 'to_block' or 'to_date'
         * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
         */
        to_date?: string;
        /** offset */
        offset?: number;
        /** limit */
        limit?: number;
      };
      path: {
        /** The address of the token contract */
        address: string;
      };
    };
    responses: {
      /** Returns a collection of token contract transactions. */
      200: {
        content: {
          "application/json": components["schemas"]["erc20TransactionCollection"];
        };
      };
    };
  };
  /** Gets the amount which the spender is allowed to withdraw from the spender */
  getTokenAllowance: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** web3 provider url to user when using local dev chain */
        providerUrl?: string;
        /** The address of the token owner */
        owner_address: string;
        /** The address of the token spender */
        spender_address: string;
      };
      path: {
        /** The address of the token contract */
        address: string;
      };
    };
    responses: {
      /** Returns the amount which the spender is allowed to withdraw from the owner.. */
      200: {
        content: {
          "application/json": components["schemas"]["erc20Allowance"];
        };
      };
    };
  };
  /** Gets NFTs that match a given metadata search. */
  searchNFTs: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The format of the token id */
        format?: "decimal" | "hex";
        /** The search string */
        q: string;
        /** What fields the search should match on. To look into the entire metadata set the value to 'global'. To have a better response time you can look into a specific field like name */
        filter?:
          | "name"
          | "description"
          | "attributes"
          | "global"
          | "name,description"
          | "name,attributes"
          | "description,attributes"
          | "name,description,attributes";
        /**
         * The minimum block number from where to start the search
         * * Provide the param 'from_block' or 'from_date'
         * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
         */
        from_block?: number;
        /**
         * The maximum block number from where to end the search
         * * Provide the param 'to_block' or 'to_date'
         * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
         */
        to_block?: number;
        /**
         * The date from where to start the search (any format that is accepted by momentjs)
         * * Provide the param 'from_block' or 'from_date'
         * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
         */
        from_date?: string;
        /**
         * Get search results up until this date (any format that is accepted by momentjs)
         * * Provide the param 'to_block' or 'to_date'
         * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
         */
        to_date?: string;
        /** The addresses to get metadata for */
        addresses?: string[];
        /** token_address */
        token_address?: string;
        /** cursor */
        cursor?: string;
        /** limit */
        limit?: number;
      };
    };
    responses: {
      /** Returns the matching NFTs */
      200: {
        content: {
          "application/json": components["schemas"]["nftMetadataCollection"];
        };
      };
    };
  };
  /** Gets the transfers of the tokens from a block number to a block number */
  getNftTransfersFromToBlock: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /**
         * The minimum block number from where to get the transfers
         * * Provide the param 'from_block' or 'from_date'
         * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
         */
        from_block?: number;
        /**
         * The maximum block number from where to get the transfers.
         * * Provide the param 'to_block' or 'to_date'
         * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
         */
        to_block?: number;
        /**
         * The date from where to get the transfers (any format that is accepted by momentjs)
         * * Provide the param 'from_block' or 'from_date'
         * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
         */
        from_date?: string;
        /**
         * Get transfers up until this date (any format that is accepted by momentjs)
         * * Provide the param 'to_block' or 'to_date'
         * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
         */
        to_date?: string;
        /** The format of the token id */
        format?: "decimal" | "hex";
        /** limit */
        limit?: number;
        /** The cursor returned in the last response (for getting the next page) */
        cursor?: string;
      };
    };
    responses: {
      /** Returns a collection of NFT transfers */
      200: {
        content: {
          "application/json": components["schemas"]["nftTransferCollection"];
        };
      };
    };
  };
  /**
   * Gets data, including metadata (where available), for all token ids for the given contract address.
   * * Results are limited to 100 per page by default
   * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
   */
  getAllTokenIds: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The format of the token id */
        format?: "decimal" | "hex";
        /** limit */
        limit?: number;
        /** The cursor returned in the last response (for getting the next page) */
        cursor?: string;
      };
      path: {
        /** Address of the contract */
        address: string;
      };
    };
    responses: {
      /** Returns a collection of nfts */
      200: {
        content: {
          "application/json": components["schemas"]["nftCollection"];
        };
      };
    };
  };
  /** Gets the transfers of the tokens matching the given parameters */
  getContractNFTTransfers: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The format of the token id */
        format?: "decimal" | "hex";
        /** limit */
        limit?: number;
        /** The cursor returned in the last response (for getting the next page) */
        cursor?: string;
      };
      path: {
        /** Address of the contract */
        address: string;
      };
    };
    responses: {
      /** Returns a collection of NFT transfers */
      200: {
        content: {
          "application/json": components["schemas"]["nftTransferCollection"];
        };
      };
    };
  };
  /**
   * Gets all owners of NFT items within a given contract collection
   * * Use after /nft/contract/{token_address} to find out who owns each token id in a collection
   * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
   */
  getNFTOwners: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The format of the token id */
        format?: "decimal" | "hex";
        /** limit */
        limit?: number;
        /** The cursor returned in the last response (for getting the next page) */
        cursor?: string;
      };
      path: {
        /** Address of the contract */
        address: string;
      };
    };
    responses: {
      /** Returns a collection of nft owners */
      200: {
        content: {
          "application/json": components["schemas"]["nftOwnerCollection"];
        };
      };
    };
  };
  /**
   * Gets the contract level metadata (name, symbol, base token uri) for the given contract
   * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
   */
  getNFTMetadata: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
      };
      path: {
        /** Address of the contract */
        address: string;
      };
    };
    responses: {
      /** Returns a collection NFT collections. */
      200: {
        content: {
          "application/json": components["schemas"]["nftContractMetadata"];
        };
      };
    };
  };
  /**
   * ReSync the metadata for an NFT
   * * The metadata flag will request a the NFT's metadata from the already existing token_uri
   * * The uri(default) flag will fetch the latest token_uri from the given NFT address. In sync mode the metadata will also be fetched
   * * The sync mode will make the endpoint synchronous so it will wait for the task to be completed before responding
   * * The async mode(default) will make the endpoint asynchronous so we will wait for the task to be completed before responding
   */
  reSyncMetadata: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The type of resync to operate */
        flag?: "uri" | "metadata";
        /** To define the behaviour of the endpoint */
        mode?: "async" | "sync";
      };
      path: {
        /** Address of the contract */
        address: string;
        /** The id of the token */
        token_id: string;
      };
    };
    responses: {
      /** (In sync mode) Resync request executed. */
      200: {
        content: {
          "application/json": components["schemas"]["metadataResync"];
        };
      };
      /** The resync request was received and will be executed. */
      202: {
        content: {
          "application/json": components["schemas"]["metadataResync"];
        };
      };
      /** (In sync mode) Resync request executed and metadata could not be updated. */
      404: {
        content: {
          "application/json": components["schemas"]["metadataResync"];
        };
      };
    };
  };
  /** Sync a Contract for NFT Index */
  syncNFTContract: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
      };
      path: {
        /** Address of the contract */
        address: string;
      };
    };
    responses: {
      /** Contract Address was triggered for index. */
      201: unknown;
    };
  };
  /**
   * Gets data, including metadata (where available), for the given token id of the given contract address.
   * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
   */
  getTokenIdMetadata: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The format of the token id */
        format?: "decimal" | "hex";
      };
      path: {
        /** Address of the contract */
        address: string;
        /** The id of the token */
        token_id: string;
      };
    };
    responses: {
      /** Returns the specified NFT */
      200: {
        content: {
          "application/json": components["schemas"]["nft"];
        };
      };
    };
  };
  /**
   * Gets all owners of NFT items within a given contract collection
   * * Use after /nft/contract/{token_address} to find out who owns each token id in a collection
   * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
   */
  getTokenIdOwners: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The format of the token id */
        format?: "decimal" | "hex";
        /** limit */
        limit?: number;
        /** The cursor returned in the last response (for getting the next page) */
        cursor?: string;
      };
      path: {
        /** Address of the contract */
        address: string;
        /** The id of the token */
        token_id: string;
      };
    };
    responses: {
      /** Returns a collection of NFTs with their respective owners */
      200: {
        content: {
          "application/json": components["schemas"]["nftOwnerCollection"];
        };
      };
    };
  };
  /** Gets the transfers of the tokens matching the given parameters */
  getWalletTokenIdTransfers: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The format of the token id */
        format?: "decimal" | "hex";
        /** limit */
        limit?: number;
        /** The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: "block_number", "block_number.ASC", "block_number.DESC", Example 2: "block_number and contract_type", "block_number.ASC,contract_type.DESC" */
        order?: string;
        /** The cursor returned in the last response (for getting the next page) */
        cursor?: string;
      };
      path: {
        /** Address of the contract */
        address: string;
        /** The id of the token */
        token_id: string;
      };
    };
    responses: {
      /** Returns a collection of NFT transfers */
      200: {
        content: {
          "application/json": components["schemas"]["nftTransferCollection"];
        };
      };
    };
  };
  /** Resolves an Unstoppable domain and returns the address */
  resolveDomain: {
    parameters: {
      query: {
        /** The currency to query */
        currency?: "eth" | "0x1";
      };
      path: {
        /** Domain to be resolved */
        domain: string;
      };
    };
    responses: {
      /** Returns an address */
      200: {
        content: {
          "application/json": components["schemas"]["resolve"];
        };
      };
      /** Returns an address */
      404: {
        content: {
          "application/json": { [key: string]: unknown };
        };
      };
    };
  };
  /** Resolves an ETH address and find the ENS name */
  resolveAddress: {
    parameters: {
      path: {
        /** The address to be resolved */
        address: string;
      };
    };
    responses: {
      /** Returns an ENS */
      200: {
        content: {
          "application/json": components["schemas"]["ens"];
        };
      };
    };
  };
  /** Get the liquidity reserves for a given pair address. Only Uniswap V2 based exchanges supported at the moment. */
  getPairReserves: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** To get the reserves at this block number */
        to_block?: string;
        /**
         * Get the reserves to this date (any format that is accepted by momentjs)
         * * Provide the param 'to_block' or 'to_date'
         * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
         */
        to_date?: string;
        /** web3 provider url to user when using local dev chain */
        provider_url?: string;
      };
      path: {
        /** Liquidity pair address */
        pair_address: string;
      };
    };
    responses: {
      /** Returns the pair reserves */
      200: {
        content: {
          "application/json": {
            /** @example 220969226548536862025877 */
            reserve0?: string;
            /** @example 844810441191293211036 */
            reserve1?: string;
          };
        };
      };
    };
  };
  /**
   * Fetches and returns pair data of the provided token0+token1 combination.
   * The token0 and token1 options are interchangable (ie. there is no different outcome in "token0=WETH and token1=USDT" or "token0=USDT and token1=WETH")
   */
  getPairAddress: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** To get the reserves at this block number */
        to_block?: string;
        /**
         * Get the reserves to this date (any format that is accepted by momentjs)
         * * Provide the param 'to_block' or 'to_date'
         * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
         */
        to_date?: string;
        /** The factory name or address of the token exchange */
        exchange:
          | "uniswapv2"
          | "uniswapv3"
          | "sushiswapv2"
          | "pancakeswapv2"
          | "pancakeswapv1"
          | "quickswap";
      };
      path: {
        /** Token0 address */
        token0_address: string;
        /** Token1 address */
        token1_address: string;
      };
    };
    responses: {
      /** Returns the pair address of the two tokens */
      200: {
        content: {
          "application/json": components["schemas"]["reservesCollection"];
        };
      };
    };
  };
  /** Uploads multiple files and place them in a folder directory */
  uploadFolder: {
    responses: {
      /** Returns the path to the uploaded files */
      200: {
        content: {
          "application/json": components["schemas"]["ipfsFile"][];
        };
      };
    };
    /** Array of JSON and Base64 Supported */
    requestBody: {
      content: {
        "application/json": components["schemas"]["ipfsFileRequest"][];
      };
    };
  };
  web3ApiVersion: {
    responses: {
      /** Returns the web3 api version */
      200: {
        content: {
          "application/json": components["schemas"]["web3version"];
        };
      };
    };
  };
  endpointWeights: {
    responses: {
      /** Returns the endpoint price list for rate limits and costs */
      200: {
        content: {
          "application/json": components["schemas"]["endpointWeights"][];
        };
      };
    };
  };
}

export interface external {}


  export interface defaultResponse<T> {
    next?: () => Promise<T & this>;
  }
  
export default class Web3Api {
  static initialize: (options: {apiKey?: string, serverUrl?: string, Moralis?: any}) => void;

  static native: {
    getBlock: (options: operations["getBlock"]["parameters"]["query"] & operations["getBlock"]["parameters"]["path"]) => Promise<operations["getBlock"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["getBlock"]["responses"]["200"]["content"]["application/json"]>>;
    getDateToBlock: (options: operations["getDateToBlock"]["parameters"]["query"]) => Promise<operations["getDateToBlock"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["getDateToBlock"]["responses"]["200"]["content"]["application/json"]>>;
    getLogsByAddress: (options: operations["getLogsByAddress"]["parameters"]["query"] & operations["getLogsByAddress"]["parameters"]["path"]) => Promise<operations["getLogsByAddress"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["getLogsByAddress"]["responses"]["200"]["content"]["application/json"]>>;
    getNFTTransfersByBlock: (options: operations["getNFTTransfersByBlock"]["parameters"]["query"] & operations["getNFTTransfersByBlock"]["parameters"]["path"]) => Promise<operations["getNFTTransfersByBlock"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["getNFTTransfersByBlock"]["responses"]["200"]["content"]["application/json"]>>;
    getTransaction: (options: operations["getTransaction"]["parameters"]["query"] & operations["getTransaction"]["parameters"]["path"]) => Promise<operations["getTransaction"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["getTransaction"]["responses"]["200"]["content"]["application/json"]>>;
    getContractEvents: (options: operations["getContractEvents"]["parameters"]["query"] & operations["getContractEvents"]["parameters"]["path"]) => Promise<operations["getContractEvents"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["getContractEvents"]["responses"]["200"]["content"]["application/json"]>>;
    runContractFunction: (options: operations["runContractFunction"]["parameters"]["query"] & operations["runContractFunction"]["parameters"]["path"]) => Promise<operations["runContractFunction"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["runContractFunction"]["responses"]["200"]["content"]["application/json"]>>;
  }

  static account: {
    getTransactions: (options: operations["getTransactions"]["parameters"]["query"] & operations["getTransactions"]["parameters"]["path"]) => Promise<operations["getTransactions"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["getTransactions"]["responses"]["200"]["content"]["application/json"]>>;
    getNativeBalance: (options: operations["getNativeBalance"]["parameters"]["query"] & operations["getNativeBalance"]["parameters"]["path"]) => Promise<operations["getNativeBalance"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["getNativeBalance"]["responses"]["200"]["content"]["application/json"]>>;
    getTokenBalances: (options: operations["getTokenBalances"]["parameters"]["query"] & operations["getTokenBalances"]["parameters"]["path"]) => Promise<operations["getTokenBalances"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["getTokenBalances"]["responses"]["200"]["content"]["application/json"]>>;
    getTokenTransfers: (options: operations["getTokenTransfers"]["parameters"]["query"] & operations["getTokenTransfers"]["parameters"]["path"]) => Promise<operations["getTokenTransfers"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["getTokenTransfers"]["responses"]["200"]["content"]["application/json"]>>;
    getNFTs: (options: operations["getNFTs"]["parameters"]["query"] & operations["getNFTs"]["parameters"]["path"]) => Promise<operations["getNFTs"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["getNFTs"]["responses"]["200"]["content"]["application/json"]>>;
    getNFTTransfers: (options: operations["getNFTTransfers"]["parameters"]["query"] & operations["getNFTTransfers"]["parameters"]["path"]) => Promise<operations["getNFTTransfers"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["getNFTTransfers"]["responses"]["200"]["content"]["application/json"]>>;
    getNFTsForContract: (options: operations["getNFTsForContract"]["parameters"]["query"] & operations["getNFTsForContract"]["parameters"]["path"]) => Promise<operations["getNFTsForContract"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["getNFTsForContract"]["responses"]["200"]["content"]["application/json"]>>;
  }

  static token: {
    getTokenMetadata: (options: operations["getTokenMetadata"]["parameters"]["query"]) => Promise<operations["getTokenMetadata"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["getTokenMetadata"]["responses"]["200"]["content"]["application/json"]>>;
    getNFTTrades: (options: operations["getNFTTrades"]["parameters"]["query"] & operations["getNFTTrades"]["parameters"]["path"]) => Promise<operations["getNFTTrades"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["getNFTTrades"]["responses"]["200"]["content"]["application/json"]>>;
    getNFTLowestPrice: (options: operations["getNFTLowestPrice"]["parameters"]["query"] & operations["getNFTLowestPrice"]["parameters"]["path"]) => Promise<operations["getNFTLowestPrice"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["getNFTLowestPrice"]["responses"]["200"]["content"]["application/json"]>>;
    getTokenMetadataBySymbol: (options: operations["getTokenMetadataBySymbol"]["parameters"]["query"]) => Promise<operations["getTokenMetadataBySymbol"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["getTokenMetadataBySymbol"]["responses"]["200"]["content"]["application/json"]>>;
    getTokenPrice: (options: operations["getTokenPrice"]["parameters"]["query"] & operations["getTokenPrice"]["parameters"]["path"]) => Promise<operations["getTokenPrice"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["getTokenPrice"]["responses"]["200"]["content"]["application/json"]>>;
    getTokenAddressTransfers: (options: operations["getTokenAddressTransfers"]["parameters"]["query"] & operations["getTokenAddressTransfers"]["parameters"]["path"]) => Promise<operations["getTokenAddressTransfers"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["getTokenAddressTransfers"]["responses"]["200"]["content"]["application/json"]>>;
    getTokenAllowance: (options: operations["getTokenAllowance"]["parameters"]["query"] & operations["getTokenAllowance"]["parameters"]["path"]) => Promise<operations["getTokenAllowance"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["getTokenAllowance"]["responses"]["200"]["content"]["application/json"]>>;
    searchNFTs: (options: operations["searchNFTs"]["parameters"]["query"]) => Promise<operations["searchNFTs"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["searchNFTs"]["responses"]["200"]["content"]["application/json"]>>;
    getNftTransfersFromToBlock: (options: operations["getNftTransfersFromToBlock"]["parameters"]["query"]) => Promise<operations["getNftTransfersFromToBlock"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["getNftTransfersFromToBlock"]["responses"]["200"]["content"]["application/json"]>>;
    getAllTokenIds: (options: operations["getAllTokenIds"]["parameters"]["query"] & operations["getAllTokenIds"]["parameters"]["path"]) => Promise<operations["getAllTokenIds"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["getAllTokenIds"]["responses"]["200"]["content"]["application/json"]>>;
    getContractNFTTransfers: (options: operations["getContractNFTTransfers"]["parameters"]["query"] & operations["getContractNFTTransfers"]["parameters"]["path"]) => Promise<operations["getContractNFTTransfers"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["getContractNFTTransfers"]["responses"]["200"]["content"]["application/json"]>>;
    getNFTOwners: (options: operations["getNFTOwners"]["parameters"]["query"] & operations["getNFTOwners"]["parameters"]["path"]) => Promise<operations["getNFTOwners"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["getNFTOwners"]["responses"]["200"]["content"]["application/json"]>>;
    getNFTMetadata: (options: operations["getNFTMetadata"]["parameters"]["query"] & operations["getNFTMetadata"]["parameters"]["path"]) => Promise<operations["getNFTMetadata"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["getNFTMetadata"]["responses"]["200"]["content"]["application/json"]>>;
    reSyncMetadata: (options: operations["reSyncMetadata"]["parameters"]["query"] & operations["reSyncMetadata"]["parameters"]["path"]) => Promise<operations["reSyncMetadata"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["reSyncMetadata"]["responses"]["200"]["content"]["application/json"]>>;
    getTokenIdMetadata: (options: operations["getTokenIdMetadata"]["parameters"]["query"] & operations["getTokenIdMetadata"]["parameters"]["path"]) => Promise<operations["getTokenIdMetadata"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["getTokenIdMetadata"]["responses"]["200"]["content"]["application/json"]>>;
    getTokenIdOwners: (options: operations["getTokenIdOwners"]["parameters"]["query"] & operations["getTokenIdOwners"]["parameters"]["path"]) => Promise<operations["getTokenIdOwners"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["getTokenIdOwners"]["responses"]["200"]["content"]["application/json"]>>;
    getWalletTokenIdTransfers: (options: operations["getWalletTokenIdTransfers"]["parameters"]["query"] & operations["getWalletTokenIdTransfers"]["parameters"]["path"]) => Promise<operations["getWalletTokenIdTransfers"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["getWalletTokenIdTransfers"]["responses"]["200"]["content"]["application/json"]>>;
  }

  static contract: {
    syncNFTContract: (options: operations["syncNFTContract"]["parameters"]["query"] & operations["syncNFTContract"]["parameters"]["path"]) => Promise<unknown & defaultResponse<unknown>>;
  }

  static resolve: {
    resolveDomain: (options: operations["resolveDomain"]["parameters"]["query"] & operations["resolveDomain"]["parameters"]["path"]) => Promise<operations["resolveDomain"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["resolveDomain"]["responses"]["200"]["content"]["application/json"]>>;
    resolveAddress: (options: operations["resolveAddress"]["parameters"]["path"]) => Promise<operations["resolveAddress"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["resolveAddress"]["responses"]["200"]["content"]["application/json"]>>;
  }

  static defi: {
    getPairReserves: (options: operations["getPairReserves"]["parameters"]["query"] & operations["getPairReserves"]["parameters"]["path"]) => Promise<operations["getPairReserves"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["getPairReserves"]["responses"]["200"]["content"]["application/json"]>>;
    getPairAddress: (options: operations["getPairAddress"]["parameters"]["query"] & operations["getPairAddress"]["parameters"]["path"]) => Promise<operations["getPairAddress"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["getPairAddress"]["responses"]["200"]["content"]["application/json"]>>;
  }

  static storage: {
    uploadFolder: () => Promise<operations["uploadFolder"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["uploadFolder"]["responses"]["200"]["content"]["application/json"]>>;
  }

  static info: {
    web3ApiVersion: () => Promise<operations["web3ApiVersion"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["web3ApiVersion"]["responses"]["200"]["content"]["application/json"]>>;
    endpointWeights: () => Promise<operations["endpointWeights"]["responses"]["200"]["content"]["application/json"] & defaultResponse<operations["endpointWeights"]["responses"]["200"]["content"]["application/json"]>>;
  }

}
