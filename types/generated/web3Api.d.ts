/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/block/{block_number_or_hash}": {
    /** Gets the contents of a block by block hash */
    get: operations["getBlock"];
  };
  "/dateToBlock": {
    /** Gets the closest block of the provided date */
    get: operations["getDateToBlock"];
  };
  "/{address}/logs": {
    /** Gets the logs from an address */
    get: operations["getLogsByAddress"];
  };
  "/block/{block_number_or_hash}/nft/transfers": {
    /** Gets NFT transfers by block number or block hash */
    get: operations["getNFTTransfersByBlock"];
  };
  "/transaction/{transaction_hash}": {
    /** Gets the contents of a block transaction by hash */
    get: operations["getTransaction"];
  };
  "/{address}/events": {
    /** Gets events in descending order based on block number */
    post: operations["getContractEvents"];
  };
  "/{address}/function": {
    /** Runs a given function of a contract abi and returns readonly data */
    post: operations["runContractFunction"];
  };
  "/{address}": {
    /** Gets native transactions in descending order based on block number */
    get: operations["getTransactions"];
  };
  "/{address}/balance": {
    /** Gets native balance for a specific address */
    get: operations["getNativeBalance"];
  };
  "/{address}/erc20": {
    /** Gets token balances for a specific address */
    get: operations["getTokenBalances"];
  };
  "/{address}/erc20/transfers": {
    /** Gets ERC20 token transactions in descending order based on block number */
    get: operations["getTokenTransfers"];
  };
  "/{address}/nft": {
    /**
     * Gets NFTs owned by the given address
     * * The response will include status [SYNCED/SYNCING] based on the contracts being indexed.
     * * Use the token_address param to get results for a specific contract only
     * * Note results will include all indexed NFTs
     * * Any request which includes the token_address param will start the indexing process for that NFT collection the very first time it is requested
     */
    get: operations["getNFTs"];
  };
  "/{address}/nft/transfers": {
    /** Gets the transfers of the tokens matching the given parameters */
    get: operations["getNFTTransfers"];
  };
  "/{address}/nft/{token_address}": {
    /**
     * Gets NFTs owned by the given address
     * * Use the token_address param to get results for a specific contract only
     * * Note results will include all indexed NFTs
     * * Any request which includes the token_address param will start the indexing process for that NFT collection the very first time it is requested
     */
    get: operations["getNFTsForContract"];
  };
  "/erc20/metadata": {
    /** Returns metadata (name, symbol, decimals, logo) for a given token contract address. */
    get: operations["getTokenMetadata"];
  };
  "/nft/{address}/trades": {
    /** Get the nft trades for a given contracts and marketplace */
    get: operations["getNFTTrades"];
  };
  "/erc20/metadata/symbols": {
    /** Returns metadata (name, symbol, decimals, logo) for a given token contract address. */
    get: operations["getTokenMetadataBySymbol"];
  };
  "/erc20/{address}/price": {
    /** Returns the price nominated in the native token and usd for a given token contract address. */
    get: operations["getTokenPrice"];
  };
  "/erc20/{address}/transfers": {
    /** Gets ERC20 token contract transactions in descending order based on block number */
    get: operations["getTokenAdressTransfers"];
  };
  "/erc20/{address}/allowance": {
    /** Gets the amount which the spender is allowed to withdraw from the spender */
    get: operations["getTokenAllowance"];
  };
  "/nft/search": {
    /** Gets NFTs that match a given metadata search. */
    get: operations["searchNFTs"];
  };
  "/nft/{address}": {
    /**
     * Gets data, including metadata (where available), for all token ids for the given contract address.
     * * Results are sorted by the block the token id was minted (descending) and limited to 100 per page by default
     * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     */
    get: operations["getAllTokenIds"];
  };
  "/nft/{address}/transfers": {
    /** Gets the transfers of the tokens matching the given parameters */
    get: operations["getContractNFTTransfers"];
  };
  "/nft/transfers": {
    /** Gets the transfers of the tokens from a block number to a block number */
    get: operations["getNftTransfersFromToBlock"];
  };
  "/nft/{address}/owners": {
    /**
     * Gets all owners of NFT items within a given contract collection
     * * Use after /nft/contract/{token_address} to find out who owns each token id in a collection
     * * Make sure to include a sort parm on a column like block_number_minted for consistent pagination results
     * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     */
    get: operations["getNFTOwners"];
  };
  "/nft/{address}/metadata": {
    /**
     * Gets the contract level metadata (name, symbol, base token uri) for the given contract
     * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     */
    get: operations["getNFTMetadata"];
  };
  "/nft/{address}/{token_id}": {
    /**
     * Gets data, including metadata (where available), for the given token id of the given contract address.
     * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     */
    get: operations["getTokenIdMetadata"];
  };
  "/nft/{address}/{token_id}/owners": {
    /**
     * Gets all owners of NFT items within a given contract collection
     * * Use after /nft/contract/{token_address} to find out who owns each token id in a collection
     * * Make sure to include a sort parm on a column like block_number_minted for consistent pagination results
     * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     */
    get: operations["getTokenIdOwners"];
  };
  "/nft/{address}/{token_id}/transfers": {
    /** Gets the transfers of the tokens matching the given parameters */
    get: operations["getWalletTokenIdTransfers"];
  };
  "/resolve/{domain}": {
    /** Resolves an Unstoppable domain and returns the address */
    get: operations["resolveDomain"];
  };
  "/{pair_address}/reserves": {
    /** Get the liquidity reserves for a given pair address */
    get: operations["getPairReserves"];
  };
  "/{token0_address}/{token1_address}/pairAddress": {
    /**
     * Fetches and returns pair data of the provided token0+token1 combination.
     * The token0 and token1 options are interchangable (ie. there is no different outcome in "token0=WETH and token1=USDT" or "token0=USDT and token1=WETH")
     */
    get: operations["getPairAddress"];
  };
  "/ipfs/uploadFolder": {
    /** Uploads multiple files and place them in a folder directory */
    post: operations["uploadFolder"];
  };
}

export interface components {
  schemas: {
    logEventByAddress: {
      /** The transaction hash */
      transaction_hash: string;
      /** The address of the contract */
      address: string;
      /** The block timestamp */
      block_timestamp: string;
      /** The block number */
      block_number: string;
      /** The block hash */
      block_hash: string;
      /** The data of the log */
      data: string;
      topic0: string;
      topic1: string;
      topic2: string;
      topic3: string;
    };
    logEvent: {
      /** The transaction hash */
      transaction_hash: string;
      /** The address of the contract */
      address: string;
      /** The block timestamp */
      block_timestamp: string;
      /** The block number */
      block_number: string;
      /** The block hash */
      block_hash: string;
      /** The content of the event */
      data: { [key: string]: unknown };
    };
    log: {
      log_index: string;
      /** The hash of the transaction */
      transaction_hash: string;
      transaction_index: string;
      /** The address of the contract */
      address: string;
      /** The data of the log */
      data: string;
      topic0: string;
      topic1?: string;
      topic2?: string;
      topic3?: string;
      /** The timestamp of the block */
      block_timestamp: string;
      /** The block number */
      block_number: string;
      /** The hash of the block */
      block_hash: string;
    };
    blockTransaction: {
      /** The hash of the transaction */
      hash: string;
      /** The nonce */
      nonce: string;
      transaction_index: string;
      /** The from address */
      from_address: string;
      /** The to address */
      to_address: string;
      /** The value sent */
      value: string;
      gas?: string;
      /** The gas price */
      gas_price: string;
      input: string;
      receipt_cumulative_gas_used: string;
      receipt_gas_used: string;
      receipt_contract_address?: string;
      receipt_root?: string;
      receipt_status: string;
      /** The block timestamp */
      block_timestamp: string;
      /** The block number */
      block_number: string;
      /** The hash of the block */
      block_hash: string;
      /** The logs of the transaction */
      logs: components["schemas"]["log"][];
    };
    block: {
      /** The block timestamp */
      timestamp: string;
      /** The block number */
      number: string;
      /** The block hash */
      hash: string;
      /** The block hash of the parent block */
      parent_hash: string;
      /** The nonce */
      nonce: string;
      sha3_uncles: string;
      logs_bloom: string;
      transactions_root: string;
      state_root: string;
      receipts_root: string;
      /** The address of the miner */
      miner: string;
      /** The difficulty of the block */
      difficulty: string;
      /** The total difficulty */
      total_difficulty: string;
      /** The block size */
      size: string;
      extra_data: string;
      /** The gas limit */
      gas_limit: string;
      /** The gas used */
      gas_used: string;
      /** The number of transactions in the block */
      transaction_count: string;
      /** The transactions in the block */
      transactions: components["schemas"]["blockTransaction"][];
    };
    blockDate: {
      /** The date of the block */
      date: number;
      /** The blocknumber */
      block: number;
      /** The timestamp of the block */
      timestamp: number;
    };
    transactionCollection: {
      /** The total number of matches for this query */
      total?: number;
      /** The page of the current result */
      page?: number;
      /** The number of results per page */
      page_size?: number;
      result?: components["schemas"]["transaction"][];
    };
    transaction: {
      /** The hash of the transaction */
      hash: string;
      /** The nonce of the transaction */
      nonce: string;
      /** The transaction index */
      transaction_index: string;
      /** The sender */
      from_address: string;
      /** The recipient */
      to_address: string;
      /** The value that was transfered (in wei) */
      value: string;
      /** The gas of the transaction */
      gas: string;
      /** The gas price */
      gas_price: string;
      /** The input */
      input: string;
      /** The receipt cumulative gas used */
      receipt_cumulative_gas_used: string;
      /** The receipt gas used */
      receipt_gas_used: string;
      /** The receipt contract address */
      receipt_contract_address: string;
      /** The receipt root */
      receipt_root: string;
      /** The receipt status */
      receipt_status: string;
      /** The block timestamp */
      block_timestamp: string;
      /** The block number */
      block_number: string;
      /** The block hash */
      block_hash: string;
    };
    erc20Allowance: {
      /** The allowance */
      allowance: string;
    };
    erc20TokenBalance: {
      /** The address of the token contract */
      token_address: string;
      /** The name of the token Contract */
      name: string;
      /** The symbol of the NFT contract */
      symbol: string;
      /** The logo of the token */
      logo?: string;
      /** The thumbnail of the logo */
      thumbnail?: string;
      /** The number of decimals on of the token */
      decimals: string;
      /** Timestamp of when the contract was last synced with the node */
      balance: string;
    };
    nativeBalance: {
      /** The balance */
      balance: string;
    };
    tradesCollection: {
      /** The token id of the NFT */
      token_id: string;
      /** The address that sent the NFT */
      from_address: string;
      /** The address that recieved the NFT */
      to_address: string;
      /** The value that was sent in the transaction (ETH/BNB/etc..) */
      value: string;
      /** The gas of the transaction */
      gas: string;
      /** The gas price */
      gas_price: string;
      /** The receipt cumulative gas used */
      receipt_cumulative_gas_used: string;
      /** The receipt gas used */
      receipt_gas_used: string;
      /** The blocknumber of the transaction */
      block_number: string;
      /** The block timestamp */
      block_timestamp: string;
      /** The transaction hash */
      transaction_hash: string;
      /** The transaction index */
      transaction_index: string;
    } & {
      nonce: unknown;
    };
    chainList:
      | "eth"
      | "0x1"
      | "ropsten"
      | "0x3"
      | "rinkeby"
      | "0x4"
      | "goerli"
      | "0x5"
      | "kovan"
      | "0x2a"
      | "polygon"
      | "0x89"
      | "mumbai"
      | "0x13881"
      | "bsc"
      | "0x38"
      | "bsc testnet"
      | "0x61"
      | "avalanche"
      | "0xa86a";
    nft: {
      /** The address of the contract of the NFT */
      token_address: string;
      /** The token id of the NFT */
      token_id: string;
      /** The type of NFT contract standard */
      contract_type: string;
      /** The uri to the metadata of the token */
      token_uri?: string;
      /** The metadata of the token */
      metadata?: string;
      /** when the metadata was last updated */
      synced_at?: string;
      /** The number of this item the user owns (used by ERC1155) */
      amount?: string;
      /** The name of the Token contract */
      name: string;
      /** The symbol of the NFT contract */
      symbol: string;
    };
    nftMetadata: {
      /** The address of the contract of the NFT */
      token_address: string;
      /** The token id of the NFT */
      token_id: string;
      /** The type of NFT contract standard */
      contract_type: string;
      /** The uri to the metadata of the token */
      token_uri: string;
      /** The metadata of the token */
      metadata: string;
      /** when the metadata was last updated */
      synced_at: string;
    } & {
      token_hash: unknown;
    };
    nftCollection: {
      /** The total number of matches for this query */
      total?: number;
      /** The page of the current result */
      page?: number;
      /** The number of results per page */
      page_size?: number;
      result?: components["schemas"]["nft"][];
    };
    nftMetadataCollection: {
      /** The total number of matches for this query */
      total?: number;
      /** The page of the current result */
      page?: number;
      /** The number of results per page */
      page_size?: number;
      result?: components["schemas"]["nftMetadata"][];
    };
    nftOwner: {
      /** The address of the contract of the NFT */
      token_address: string;
      /** The token id of the NFT */
      token_id: string;
      /** The type of NFT contract standard */
      contract_type: string;
      /** The address of the owner of the NFT */
      owner_of: string;
      /** The blocknumber when the amount or owner changed */
      block_number: string;
      /** The blocknumber when the NFT was minted */
      block_number_minted: string;
      /** The uri to the metadata of the token */
      token_uri?: string;
      /** The metadata of the token */
      metadata?: string;
      /** when the metadata was last updated */
      synced_at?: string;
      /** The number of this item the user owns (used by ERC1155) */
      amount?: string;
      /** The name of the Token contract */
      name: string;
      /** The symbol of the NFT contract */
      symbol: string;
    };
    nftOwnerCollection: {
      /** The syncing status of the address [SYNCING/SYNCED] */
      status?: string;
      /** The total number of matches for this query */
      total?: number;
      /** The page of the current result */
      page?: number;
      /** The number of results per page */
      page_size?: number;
      result?: components["schemas"]["nftOwner"][];
    };
    nftTransfer: {
      /** The address of the contract of the NFT */
      token_address: string;
      /** The token id of the NFT */
      token_id: string;
      /** The address that sent the NFT */
      from_address?: string;
      /** The address that recieved the NFT */
      to_address: string;
      /** The value that was sent in the transaction (ETH/BNB/etc..) */
      value?: string;
      /** The number of tokens transferred */
      amount?: string;
      /** The type of NFT contract standard */
      contract_type: string;
      /** The blocknumber of the transaction */
      block_number: string;
      /** The block timestamp */
      block_timestamp: string;
      /** The block hash of the transaction */
      block_hash: string;
      /** The transaction hash */
      transaction_hash: string;
      /** The transaction type */
      transaction_type?: string;
      /** The transaction index */
      transaction_index?: string;
      /** The log index */
      log_index: number;
      /** The operator present only for ERC1155 Transfers */
      operator?: string;
    };
    nftTransferCollection: {
      /** The total number of matches for this query */
      total: number;
      /** The page of the current result */
      page: number;
      /** The number of results per page */
      page_size: number;
      result: components["schemas"]["nftTransfer"][];
    };
    nftContractMetadata: {
      /** The address of the token contract */
      token_address: string;
      /** The name of the token Contract */
      name: string;
      /** The abi of the token Contract */
      abi?: string;
      /** value -1 if the contract does not support token_uri */
      supports_token_uri?: number;
      /** Timestamp of when the contract was last synced with the node */
      synced_at?: string;
      /** The symbol of the NFT contract */
      symbol: string;
      /** The type of NFT contract */
      contract_type: string;
    };
    nftContractMetadataCollection: {
      /** The total number of matches for this query */
      total: number;
      /** The page of the current result */
      page: number;
      /** The number of results per page */
      page_size: number;
      result: components["schemas"]["nftContractMetadata"][];
    };
    erc20Transaction: {
      /** The transaction hash */
      transaction_hash: string;
      /** The address of the token */
      address: string;
      /** The block timestamp */
      block_timestamp: string;
      /** The block number */
      block_number: string;
      /** The block hash */
      block_hash: string;
      /** The recipient */
      to_address: string;
      /** The sender */
      from_address: string;
      /** The value that was transfered (in wei) */
      value: string;
    };
    historicalNftTransfer: {
      /** The transaction hash */
      transaction_hash: string;
      /** The address of the token */
      address: string;
      /** The block timestamp */
      block_timestamp: string;
      /** The block number */
      block_number: string;
      /** The block hash */
      block_hash: string;
      /** The recipient */
      to_address: string;
      /** The sender */
      from_address: string;
      /** The token ids of the tokens that were transfered */
      token_ids: string[];
      /** The amounts that were transfered */
      amounts: string[];
      /** They contract type of the transfer */
      contract_type: string;
    };
    erc20Metadata: {
      /** The address of the token contract */
      address: string;
      /** The name of the token Contract */
      name: string;
      /** The symbol of the NFT contract */
      symbol: string;
      /** The number of decimals on of the token */
      decimals: string;
      /** The logo of the token */
      logo?: string;
      /** The logo hash */
      logo_hash?: string;
      /** The thumbnail of the logo */
      thumbnail?: string;
      block_number?: string;
      validated?: string;
    };
    erc721Metadata: {
      /** The name of the token Contract */
      name: string;
      /** The symbol of the NFT contract */
      symbol: string;
      token_uri?: string;
    };
    erc20Price: {
      nativePrice?: components["schemas"]["nativeErc20Price"];
      /** The price in USD for the token */
      usdPrice: number;
      /** The address of the exchange used to calculate the price */
      exchangeAddress?: string;
      /** The name of the exchange used for calculating the price */
      exchangeName?: string;
    } & {
      symbol: unknown;
    };
    nativeErc20Price: {
      /** The native price of the token */
      value: string;
      /** The number of decimals of the token */
      decimals: number;
      /** The Name of the token */
      name: string;
      /** The Symbol of the token */
      symbol: string;
    };
    resolve: {
      /** Resolved domain address */
      address: string;
    };
    reservesCollection: {
      /** reserve0 */
      reserve0: string;
      /** reserve1 */
      reserve1: string;
    };
    ipfsFileRequest: {
      /** Path to file */
      path: string;
      /** base64 or JSON */
      content: string;
    };
    ipfsFile: {
      /** Path to file */
      path: string;
    };
  };
}

export interface operations {
  /** Gets the contents of a block by block hash */
  getBlock: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The subdomain of the moralis server to use (Only use when selecting local devchain as chain) */
        subdomain?: string;
      };
      path: {
        /** The block hash or block number */
        block_number_or_hash: string;
      };
    };
    responses: {
      /** Returns the contents of a block */
      200: {
        content: {
          "application/json": components["schemas"]["block"];
        };
      };
    };
  };
  /** Gets the closest block of the provided date */
  getDateToBlock: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** web3 provider url to user when using local dev chain */
        providerUrl?: string;
        /** Unix date in miliseconds or a datestring (any format that is accepted by momentjs) */
        date: string;
      };
    };
    responses: {
      /** Returns the blocknumber and corresponding date and timestamp */
      200: {
        content: {
          "application/json": components["schemas"]["blockDate"];
        };
      };
    };
  };
  /** Gets the logs from an address */
  getLogsByAddress: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The subdomain of the moralis server to use (Only use when selecting local devchain as chain) */
        subdomain?: string;
        /**
         * The block number
         * * Provide the param 'block_numer' or ('from_block' and / or 'to_block')
         * * If 'block_numer' is provided in conbinaison with 'from_block' and / or 'to_block', 'block_number' will will be used
         */
        block_number?: string;
        /**
         * The minimum block number from where to get the logs
         * * Provide the param 'block_numer' or ('from_block' and / or 'to_block')
         * * If 'block_numer' is provided in conbinaison with 'from_block' and / or 'to_block', 'block_number' will will be used
         */
        from_block?: string;
        /**
         * The maximum block number from where to get the logs
         * * Provide the param 'block_numer' or ('from_block' and / or 'to_block')
         * * If 'block_numer' is provided in conbinaison with 'from_block' and / or 'to_block', 'block_number' will will be used
         */
        to_block?: string;
        /**
         * The date from where to get the logs (any format that is accepted by momentjs)
         * * Provide the param 'from_block' or 'from_date'
         * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
         * * If 'from_date' and the block params are provided, the block params will be used. Please refer to the blocks params sections (block_number,from_block and to_block) on how to use them
         */
        from_date?: string;
        /**
         * Get the logs to this date (any format that is accepted by momentjs)
         * * Provide the param 'to_block' or 'to_date'
         * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
         * * If 'to_date' and the block params are provided, the block params will be used. Please refer to the blocks params sections (block_number,from_block and to_block) on how to use them
         */
        to_date?: string;
        /** topic0 */
        topic0?: string;
        /** topic1 */
        topic1?: string;
        /** topic2 */
        topic2?: string;
        /** topic3 */
        topic3?: string;
      };
      path: {
        /** address */
        address: string;
      };
    };
    responses: {
      /** Returns the logs of an address */
      200: {
        content: {
          "application/json": components["schemas"]["logEventByAddress"];
        };
      };
    };
  };
  /** Gets NFT transfers by block number or block hash */
  getNFTTransfersByBlock: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The subdomain of the moralis server to use (Only use when selecting local devchain as chain) */
        subdomain?: string;
      };
      path: {
        /** The block hash or block number */
        block_number_or_hash: string;
      };
    };
    responses: {
      /** Returns the contents of a block */
      200: {
        content: {
          "application/json": components["schemas"]["nftTransferCollection"];
        };
      };
    };
  };
  /** Gets the contents of a block transaction by hash */
  getTransaction: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The subdomain of the moralis server to use (Only use when selecting local devchain as chain) */
        subdomain?: string;
      };
      path: {
        /** The transaction hash */
        transaction_hash: string;
      };
    };
    responses: {
      /** Returns the contents of a block transaction */
      200: {
        content: {
          "application/json": components["schemas"]["blockTransaction"];
        };
      };
    };
  };
  /** Gets events in descending order based on block number */
  getContractEvents: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The subdomain of the moralis server to use (Only use when selecting local devchain as chain) */
        subdomain?: string;
        /** web3 provider url to user when using local dev chain */
        providerUrl?: string;
        /**
         * The minimum block number from where to get the logs
         * * Provide the param 'from_block' or 'from_date'
         * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
         */
        from_block?: number;
        /**
         * The maximum block number from where to get the logs.
         * * Provide the param 'to_block' or 'to_date'
         * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
         */
        to_block?: number;
        /**
         * The date from where to get the logs (any format that is accepted by momentjs)
         * * Provide the param 'from_block' or 'from_date'
         * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
         */
        from_date?: string;
        /**
         * Get the logs to this date (any format that is accepted by momentjs)
         * * Provide the param 'to_block' or 'to_date'
         * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
         */
        to_date?: string;
        /** The topic of the event */
        topic: string;
        /** offset */
        offset?: number;
        /** limit */
        limit?: number;
      };
      path: {
        /** address */
        address: string;
      };
    };
    responses: {
      /** Returns a collection of events by topic */
      200: {
        content: {
          "application/json": components["schemas"]["logEvent"][];
        };
      };
    };
    /** ABI of the specific event */
    requestBody: {
      content: {
        "application/json": { [key: string]: unknown };
      };
    };
  };
  /** Runs a given function of a contract abi and returns readonly data */
  runContractFunction: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The subdomain of the moralis server to use (Only use when selecting local devchain as chain) */
        subdomain?: string;
        /** web3 provider url to user when using local dev chain */
        providerUrl?: string;
        /** function_name */
        function_name: string;
      };
      path: {
        /** address */
        address: string;
      };
    };
    responses: {
      /** Returns response of the function executed */
      200: {
        content: {
          "application/json": string;
        };
      };
    };
    /** The contract abi */
    requestBody: {
      content: {
        "application/json": { [key: string]: unknown };
      };
    };
  };
  /** Gets native transactions in descending order based on block number */
  getTransactions: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The subdomain of the moralis server to use (Only use when selecting local devchain as chain) */
        subdomain?: string;
        /**
         * The minimum block number from where to get the transactions
         * * Provide the param 'from_block' or 'from_date'
         * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
         */
        from_block?: number;
        /**
         * The maximum block number from where to get the transactions.
         * * Provide the param 'to_block' or 'to_date'
         * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
         */
        to_block?: number;
        /**
         * The date from where to get the transactions (any format that is accepted by momentjs)
         * * Provide the param 'from_block' or 'from_date'
         * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
         */
        from_date?: string;
        /**
         * Get the transactions to this date (any format that is accepted by momentjs)
         * * Provide the param 'to_block' or 'to_date'
         * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
         */
        to_date?: string;
        /** offset */
        offset?: number;
        /** limit */
        limit?: number;
      };
      path: {
        /** address */
        address: string;
      };
    };
    responses: {
      /** Returns a collection of native transactions. */
      200: {
        content: {
          "application/json": components["schemas"]["transactionCollection"];
        };
      };
    };
  };
  /** Gets native balance for a specific address */
  getNativeBalance: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** web3 provider url to user when using local dev chain */
        providerUrl?: string;
        /** The block number on which the balances should be checked */
        to_block?: number;
      };
      path: {
        /** The address for which the native balance will be checked */
        address: string;
      };
    };
    responses: {
      /** Returns native balance for a specific address */
      200: {
        content: {
          "application/json": components["schemas"]["nativeBalance"];
        };
      };
    };
  };
  /** Gets token balances for a specific address */
  getTokenBalances: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The subdomain of the moralis server to use (Only use when selecting local devchain as chain) */
        subdomain?: string;
        /** The block number on which the balances should be checked */
        to_block?: number;
      };
      path: {
        /** The address for which token balances will be checked */
        address: string;
      };
    };
    responses: {
      /** Returns token balances for a specific address */
      200: {
        content: {
          "application/json": components["schemas"]["erc20TokenBalance"][];
        };
      };
    };
  };
  /** Gets ERC20 token transactions in descending order based on block number */
  getTokenTransfers: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The subdomain of the moralis server to use (Only use when selecting local devchain as chain) */
        subdomain?: string;
        /**
         * The minimum block number from where to get the transactions
         * * Provide the param 'from_block' or 'from_date'
         * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
         */
        from_block?: number;
        /**
         * The maximum block number from where to get the transactions.
         * * Provide the param 'to_block' or 'to_date'
         * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
         */
        to_block?: number;
        /**
         * The date from where to get the transactions (any format that is accepted by momentjs)
         * * Provide the param 'from_block' or 'from_date'
         * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
         */
        from_date?: string;
        /**
         * Get the transactions to this date (any format that is accepted by momentjs)
         * * Provide the param 'to_block' or 'to_date'
         * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
         */
        to_date?: string;
        /** offset */
        offset?: number;
        /** limit */
        limit?: number;
      };
      path: {
        /** address */
        address: string;
      };
    };
    responses: {
      /** Returns a collection of token transactions. */
      200: {
        content: {
          "application/json": components["schemas"]["erc20Transaction"][];
        };
      };
    };
  };
  /**
   * Gets NFTs owned by the given address
   * * The response will include status [SYNCED/SYNCING] based on the contracts being indexed.
   * * Use the token_address param to get results for a specific contract only
   * * Note results will include all indexed NFTs
   * * Any request which includes the token_address param will start the indexing process for that NFT collection the very first time it is requested
   */
  getNFTs: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The format of the token id */
        format?: "decimal" | "hex";
        /** offset */
        offset?: number;
        /** limit */
        limit?: number;
        /** The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: "name", "name.ASC", "name.DESC", Example 2: "Name and Symbol", "name.ASC,symbol.DESC" */
        order?: string;
      };
      path: {
        /** The owner of a given token */
        address: string;
      };
    };
    responses: {
      /** Returns a collection of nft owners */
      200: {
        content: {
          "application/json": components["schemas"]["nftOwnerCollection"];
        };
      };
    };
  };
  /** Gets the transfers of the tokens matching the given parameters */
  getNFTTransfers: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The format of the token id */
        format?: "decimal" | "hex";
        /** The transfer direction */
        direction?: "both" | "to" | "from";
        /** offset */
        offset?: number;
        /** limit */
        limit?: number;
        /** The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: "token_address", "token_address.ASC", "token_address.DESC", Example 2: "token_address and token_id", "token_address.ASC,token_id.DESC" */
        order?: string;
      };
      path: {
        /** The sender or recepient of the transfer */
        address: string;
      };
    };
    responses: {
      /** Returns a collection of NFT transfer */
      200: {
        content: {
          "application/json": components["schemas"]["nftTransferCollection"];
        };
      };
    };
  };
  /**
   * Gets NFTs owned by the given address
   * * Use the token_address param to get results for a specific contract only
   * * Note results will include all indexed NFTs
   * * Any request which includes the token_address param will start the indexing process for that NFT collection the very first time it is requested
   */
  getNFTsForContract: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The format of the token id */
        format?: "decimal" | "hex";
        /** offset */
        offset?: number;
        /** limit */
        limit?: number;
        /** The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: "name", "name.ASC", "name.DESC", Example 2: "Name and Symbol", "name.ASC,symbol.DESC" */
        order?: string;
      };
      path: {
        /** The owner of a given token */
        address: string;
        /** Address of the contract */
        token_address: string;
      };
    };
    responses: {
      /** Returns a collection of nft owners */
      200: {
        content: {
          "application/json": components["schemas"]["nftOwnerCollection"];
        };
      };
    };
  };
  /** Returns metadata (name, symbol, decimals, logo) for a given token contract address. */
  getTokenMetadata: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The subdomain of the moralis server to use (Only use when selecting local devchain as chain) */
        subdomain?: string;
        /** web3 provider url to user when using local dev chain */
        providerUrl?: string;
        /** The addresses to get metadata for */
        addresses: string[];
      };
    };
    responses: {
      /** Returns metadata (name, symbol, decimals, logo) for a given token contract address. */
      200: {
        content: {
          "application/json": components["schemas"]["erc20Metadata"][];
        };
      };
    };
  };
  /** Get the nft trades for a given contracts and marketplace */
  getNFTTrades: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /**
         * The minimum block number from where to get the transfers
         * * Provide the param 'from_block' or 'from_date'
         * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
         */
        from_block?: number;
        /** To get the reserves at this block number */
        to_block?: string;
        /**
         * The date from where to get the transfers (any format that is accepted by momentjs)
         * * Provide the param 'from_block' or 'from_date'
         * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
         */
        from_date?: string;
        /**
         * Get the reserves to this date (any format that is accepted by momentjs)
         * * Provide the param 'to_block' or 'to_date'
         * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
         */
        to_date?: string;
        /** web3 provider url to user when using local dev chain */
        provider_url?: string;
        /** marketplace from where to get the trades (only opensea is supported at the moment) */
        marketplace?: string;
        /** offset */
        offset?: number;
        /** limit */
        limit?: number;
      };
      path: {
        /** Address of the contract */
        token_address: string;
      };
    };
    responses: {
      /** Returns the trades */
      200: {
        content: {
          "application/json": components["schemas"]["tradesCollection"];
        };
      };
    };
  };
  /** Returns metadata (name, symbol, decimals, logo) for a given token contract address. */
  getTokenMetadataBySymbol: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The subdomain of the moralis server to use (Only use when selecting local devchain as chain) */
        subdomain?: string;
        /** The symbols to get metadata for */
        symbols: string[];
      };
    };
    responses: {
      /** Returns metadata (name, symbol, decimals, logo) for a given token contract address. */
      200: {
        content: {
          "application/json": components["schemas"]["erc20Metadata"][];
        };
      };
    };
  };
  /** Returns the price nominated in the native token and usd for a given token contract address. */
  getTokenPrice: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** web3 provider url to user when using local dev chain */
        providerUrl?: string;
        /** The factory name or address of the token exchange */
        exchange?: string;
        /** to_block */
        to_block?: number;
      };
      path: {
        /** The address of the token contract */
        address: string;
      };
    };
    responses: {
      /** Returns the price nominated in the native token and usd for a given token contract address */
      200: {
        content: {
          "application/json": components["schemas"]["erc20Price"];
        };
      };
    };
  };
  /** Gets ERC20 token contract transactions in descending order based on block number */
  getTokenAdressTransfers: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The subdomain of the moralis server to use (Only use when selecting local devchain as chain) */
        subdomain?: string;
        /**
         * The minimum block number from where to get the transfers
         * * Provide the param 'from_block' or 'from_date'
         * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
         */
        from_block?: number;
        /**
         * The maximum block number from where to get the transfers.
         * * Provide the param 'to_block' or 'to_date'
         * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
         */
        to_block?: number;
        /**
         * The date from where to get the transfers (any format that is accepted by momentjs)
         * * Provide the param 'from_block' or 'from_date'
         * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
         */
        from_date?: string;
        /**
         * Get the transfers to this date (any format that is accepted by momentjs)
         * * Provide the param 'to_block' or 'to_date'
         * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
         */
        to_date?: string;
        /** offset */
        offset?: number;
        /** limit */
        limit?: number;
      };
      path: {
        /** The address of the token contract */
        address: string;
      };
    };
    responses: {
      /** Returns a collection of token contract transactions. */
      200: {
        content: {
          "application/json": components["schemas"]["erc20Transaction"][];
        };
      };
    };
  };
  /** Gets the amount which the spender is allowed to withdraw from the spender */
  getTokenAllowance: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** web3 provider url to user when using local dev chain */
        providerUrl?: string;
        /** The address of the token owner */
        owner_address: string;
        /** The address of the token spender */
        spender_address: string;
      };
      path: {
        /** The address of the token contract */
        address: string;
      };
    };
    responses: {
      /** Returns the amount which the spender is allowed to withdraw from the owner.. */
      200: {
        content: {
          "application/json": components["schemas"]["erc20Allowance"];
        };
      };
    };
  };
  /** Gets NFTs that match a given metadata search. */
  searchNFTs: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The format of the token id */
        format?: "decimal" | "hex";
        /** The search string */
        q: string;
        /** What fields the search should match on. To look into the entire metadata set the value to 'global'. To have a better response time you can look into a specific field like name */
        filter?:
          | "name"
          | "description"
          | "attributes"
          | "global"
          | "name,description"
          | "name,attributes"
          | "description,attributes"
          | "name,description,attributes";
        /**
         * The minimum block number from where to start the search
         * * Provide the param 'from_block' or 'from_date'
         * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
         */
        from_block?: number;
        /**
         * The maximum block number from where to end the search
         * * Provide the param 'to_block' or 'to_date'
         * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
         */
        to_block?: number;
        /**
         * The date from where to start the search (any format that is accepted by momentjs)
         * * Provide the param 'from_block' or 'from_date'
         * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
         */
        from_date?: string;
        /**
         * Get search results up until this date (any format that is accepted by momentjs)
         * * Provide the param 'to_block' or 'to_date'
         * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
         */
        to_date?: string;
        /** offset */
        offset?: number;
        /** limit */
        limit?: number;
      };
    };
    responses: {
      /** Returns the matching NFTs */
      200: {
        content: {
          "application/json": components["schemas"]["nftMetadataCollection"];
        };
      };
    };
  };
  /**
   * Gets data, including metadata (where available), for all token ids for the given contract address.
   * * Results are sorted by the block the token id was minted (descending) and limited to 100 per page by default
   * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
   */
  getAllTokenIds: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The format of the token id */
        format?: "decimal" | "hex";
        /** offset */
        offset?: number;
        /** limit */
        limit?: number;
        /** If the order should be Ascending or Descending based on the blocknumber on which the NFT was minted. Allowed values: "ASC", "DESC" */
        order?: string;
      };
      path: {
        /** Address of the contract */
        address: string;
      };
    };
    responses: {
      /** Returns a collection of nfts */
      200: {
        content: {
          "application/json": components["schemas"]["nftCollection"];
        };
      };
    };
  };
  /** Gets the transfers of the tokens matching the given parameters */
  getContractNFTTransfers: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The format of the token id */
        format?: "decimal" | "hex";
        /** offset */
        offset?: number;
        /** limit */
        limit?: number;
        /** The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: "block_number", "block_number.ASC", "block_number.DESC", Example 2: "block_number and contract_type", "block_number.ASC,contract_type.DESC" */
        order?: string;
      };
      path: {
        /** Address of the contract */
        address: string;
      };
    };
    responses: {
      /** Returns a collection of NFT transfers */
      200: {
        content: {
          "application/json": components["schemas"]["nftTransferCollection"];
        };
      };
    };
  };
  /** Gets the transfers of the tokens from a block number to a block number */
  getNftTransfersFromToBlock: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /**
         * The minimum block number from where to get the transfers
         * * Provide the param 'from_block' or 'from_date'
         * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
         */
        from_block?: number;
        /**
         * The maximum block number from where to get the transfers.
         * * Provide the param 'to_block' or 'to_date'
         * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
         */
        to_block?: number;
        /**
         * The date from where to get the transfers (any format that is accepted by momentjs)
         * * Provide the param 'from_block' or 'from_date'
         * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
         */
        from_date?: string;
        /**
         * Get transfers up until this date (any format that is accepted by momentjs)
         * * Provide the param 'to_block' or 'to_date'
         * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
         */
        to_date?: string;
        /** The format of the token id */
        format?: "decimal" | "hex";
        /** offset */
        offset?: number;
        /** limit */
        limit?: number;
        /** The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: "block_number", "block_number.ASC", "block_number.DESC", Example 2: "block_number and contract_type", "block_number.ASC,contract_type.DESC" */
        order?: string;
      };
    };
    responses: {
      /** Returns a collection of NFT transfers */
      200: {
        content: {
          "application/json": components["schemas"]["nftTransferCollection"];
        };
      };
    };
  };
  /**
   * Gets all owners of NFT items within a given contract collection
   * * Use after /nft/contract/{token_address} to find out who owns each token id in a collection
   * * Make sure to include a sort parm on a column like block_number_minted for consistent pagination results
   * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
   */
  getNFTOwners: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The format of the token id */
        format?: "decimal" | "hex";
        /** offset */
        offset?: number;
        /** limit */
        limit?: number;
        /** The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: "name", "name.ASC", "name.DESC", Example 2: "Name and Symbol", "name.ASC,symbol.DESC" */
        order?: string;
      };
      path: {
        /** Address of the contract */
        address: string;
      };
    };
    responses: {
      /** Returns a collection of nft owners */
      200: {
        content: {
          "application/json": components["schemas"]["nftOwnerCollection"];
        };
      };
    };
  };
  /**
   * Gets the contract level metadata (name, symbol, base token uri) for the given contract
   * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
   */
  getNFTMetadata: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
      };
      path: {
        /** Address of the contract */
        address: string;
      };
    };
    responses: {
      /** Returns a collection NFT collections. */
      200: {
        content: {
          "application/json": components["schemas"]["nftContractMetadata"];
        };
      };
    };
  };
  /**
   * Gets data, including metadata (where available), for the given token id of the given contract address.
   * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
   */
  getTokenIdMetadata: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The format of the token id */
        format?: "decimal" | "hex";
      };
      path: {
        /** Address of the contract */
        address: string;
        /** The id of the token */
        token_id: string;
      };
    };
    responses: {
      /** Returns the specified NFT */
      200: {
        content: {
          "application/json": components["schemas"]["nft"];
        };
      };
    };
  };
  /**
   * Gets all owners of NFT items within a given contract collection
   * * Use after /nft/contract/{token_address} to find out who owns each token id in a collection
   * * Make sure to include a sort parm on a column like block_number_minted for consistent pagination results
   * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
   */
  getTokenIdOwners: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The format of the token id */
        format?: "decimal" | "hex";
        /** offset */
        offset?: number;
        /** limit */
        limit?: number;
        /** The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: "name", "name.ASC", "name.DESC", Example 2: "Name and Symbol", "name.ASC,symbol.DESC" */
        order?: string;
      };
      path: {
        /** Address of the contract */
        address: string;
        /** The id of the token */
        token_id: string;
      };
    };
    responses: {
      /** Returns a collection of NFTs with their respective owners */
      200: {
        content: {
          "application/json": components["schemas"]["nftOwnerCollection"];
        };
      };
    };
  };
  /** Gets the transfers of the tokens matching the given parameters */
  getWalletTokenIdTransfers: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** The format of the token id */
        format?: "decimal" | "hex";
        /** offset */
        offset?: number;
        /** limit */
        limit?: number;
        /** The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: "block_number", "block_number.ASC", "block_number.DESC", Example 2: "block_number and contract_type", "block_number.ASC,contract_type.DESC" */
        order?: string;
      };
      path: {
        /** Address of the contract */
        address: string;
        /** The id of the token */
        token_id: string;
      };
    };
    responses: {
      /** Returns a collection of NFT transfers */
      200: {
        content: {
          "application/json": components["schemas"]["nftTransferCollection"];
        };
      };
    };
  };
  /** Resolves an Unstoppable domain and returns the address */
  resolveDomain: {
    parameters: {
      query: {
        /** The currency to query */
        currency?: "eth" | "0x1";
      };
      path: {
        /** Domain to be resolved */
        domain: string;
      };
    };
    responses: {
      /** Returns an address */
      200: {
        content: {
          "application/json": components["schemas"]["resolve"];
        };
      };
    };
  };
  /** Get the liquidity reserves for a given pair address */
  getPairReserves: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** To get the reserves at this block number */
        to_block?: string;
        /**
         * Get the reserves to this date (any format that is accepted by momentjs)
         * * Provide the param 'to_block' or 'to_date'
         * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
         */
        to_date?: string;
        /** web3 provider url to user when using local dev chain */
        provider_url?: string;
      };
      path: {
        /** Liquidity pair address */
        pair_address: string;
      };
    };
    responses: {
      /** Returns the pair reserves */
      200: {
        content: {
          "application/json": components["schemas"]["reservesCollection"];
        };
      };
    };
  };
  /**
   * Fetches and returns pair data of the provided token0+token1 combination.
   * The token0 and token1 options are interchangable (ie. there is no different outcome in "token0=WETH and token1=USDT" or "token0=USDT and token1=WETH")
   */
  getPairAddress: {
    parameters: {
      query: {
        /** The chain to query */
        chain?: components["schemas"]["chainList"];
        /** To get the reserves at this block number */
        to_block?: string;
        /**
         * Get the reserves to this date (any format that is accepted by momentjs)
         * * Provide the param 'to_block' or 'to_date'
         * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
         */
        to_date?: string;
        /** The factory name or address of the token exchange */
        exchange:
          | "uniswapv2"
          | "uniswapv3"
          | "sushiswapv2"
          | "pancakeswapv2"
          | "pancakeswapv1"
          | "quickswap";
      };
      path: {
        /** Token0 address */
        token0_address: string;
        /** Token1 address */
        token1_address: string;
      };
    };
    responses: {
      /** Returns the pair address of the two tokens */
      200: {
        content: {
          "application/json": components["schemas"]["reservesCollection"];
        };
      };
    };
  };
  /** Uploads multiple files and place them in a folder directory */
  uploadFolder: {
    responses: {
      /** Returns the path to the uploaded files */
      200: {
        content: {
          "application/json": components["schemas"]["ipfsFile"][];
        };
      };
    };
    /** Array of JSON and Base64 Supported */
    requestBody: {
      content: {
        "application/json": components["schemas"]["ipfsFileRequest"][];
      };
    };
  };
}

export interface external {}

export default class Web3Api {
  static initialize: (serverUrl: string) => void;

  static native: {
    getBlock: (options: operations["getBlock"]["parameters"]["query"] & operations["getBlock"]["parameters"]["path"]) => Promise<operations["getBlock"]["responses"]["200"]["content"]["application/json"]>;
    getDateToBlock: (options: operations["getDateToBlock"]["parameters"]["query"] ) => Promise<operations["getDateToBlock"]["responses"]["200"]["content"]["application/json"]>;
    getLogsByAddress: (options: operations["getLogsByAddress"]["parameters"]["query"] & operations["getLogsByAddress"]["parameters"]["path"]) => Promise<operations["getLogsByAddress"]["responses"]["200"]["content"]["application/json"]>;
    getNFTTransfersByBlock: (options: operations["getNFTTransfersByBlock"]["parameters"]["query"] & operations["getNFTTransfersByBlock"]["parameters"]["path"]) => Promise<operations["getNFTTransfersByBlock"]["responses"]["200"]["content"]["application/json"]>;
    getTransaction: (options: operations["getTransaction"]["parameters"]["query"] & operations["getTransaction"]["parameters"]["path"]) => Promise<operations["getTransaction"]["responses"]["200"]["content"]["application/json"]>;
    getContractEvents: (options: operations["getContractEvents"]["parameters"]["query"] & operations["getContractEvents"]["parameters"]["path"]) => Promise<operations["getContractEvents"]["responses"]["200"]["content"]["application/json"]>;
    runContractFunction: (options: operations["runContractFunction"]["parameters"]["query"] & operations["runContractFunction"]["parameters"]["path"]) => Promise<operations["runContractFunction"]["responses"]["200"]["content"]["application/json"]>;
  }

  static account: {
    getTransactions: (options: operations["getTransactions"]["parameters"]["query"] & operations["getTransactions"]["parameters"]["path"]) => Promise<operations["getTransactions"]["responses"]["200"]["content"]["application/json"]>;
    getNativeBalance: (options: operations["getNativeBalance"]["parameters"]["query"] & operations["getNativeBalance"]["parameters"]["path"]) => Promise<operations["getNativeBalance"]["responses"]["200"]["content"]["application/json"]>;
    getTokenBalances: (options: operations["getTokenBalances"]["parameters"]["query"] & operations["getTokenBalances"]["parameters"]["path"]) => Promise<operations["getTokenBalances"]["responses"]["200"]["content"]["application/json"]>;
    getTokenTransfers: (options: operations["getTokenTransfers"]["parameters"]["query"] & operations["getTokenTransfers"]["parameters"]["path"]) => Promise<operations["getTokenTransfers"]["responses"]["200"]["content"]["application/json"]>;
    getNFTs: (options: operations["getNFTs"]["parameters"]["query"] & operations["getNFTs"]["parameters"]["path"]) => Promise<operations["getNFTs"]["responses"]["200"]["content"]["application/json"]>;
    getNFTTransfers: (options: operations["getNFTTransfers"]["parameters"]["query"] & operations["getNFTTransfers"]["parameters"]["path"]) => Promise<operations["getNFTTransfers"]["responses"]["200"]["content"]["application/json"]>;
    getNFTsForContract: (options: operations["getNFTsForContract"]["parameters"]["query"] & operations["getNFTsForContract"]["parameters"]["path"]) => Promise<operations["getNFTsForContract"]["responses"]["200"]["content"]["application/json"]>;
  }

  static token: {
    getTokenMetadata: (options: operations["getTokenMetadata"]["parameters"]["query"] ) => Promise<operations["getTokenMetadata"]["responses"]["200"]["content"]["application/json"]>;
    getNFTTrades: (options: operations["getNFTTrades"]["parameters"]["query"] & operations["getNFTTrades"]["parameters"]["path"]) => Promise<operations["getNFTTrades"]["responses"]["200"]["content"]["application/json"]>;
    getTokenMetadataBySymbol: (options: operations["getTokenMetadataBySymbol"]["parameters"]["query"] ) => Promise<operations["getTokenMetadataBySymbol"]["responses"]["200"]["content"]["application/json"]>;
    getTokenPrice: (options: operations["getTokenPrice"]["parameters"]["query"] & operations["getTokenPrice"]["parameters"]["path"]) => Promise<operations["getTokenPrice"]["responses"]["200"]["content"]["application/json"]>;
    getTokenAdressTransfers: (options: operations["getTokenAdressTransfers"]["parameters"]["query"] & operations["getTokenAdressTransfers"]["parameters"]["path"]) => Promise<operations["getTokenAdressTransfers"]["responses"]["200"]["content"]["application/json"]>;
    getTokenAllowance: (options: operations["getTokenAllowance"]["parameters"]["query"] & operations["getTokenAllowance"]["parameters"]["path"]) => Promise<operations["getTokenAllowance"]["responses"]["200"]["content"]["application/json"]>;
    searchNFTs: (options: operations["searchNFTs"]["parameters"]["query"] ) => Promise<operations["searchNFTs"]["responses"]["200"]["content"]["application/json"]>;
    getAllTokenIds: (options: operations["getAllTokenIds"]["parameters"]["query"] & operations["getAllTokenIds"]["parameters"]["path"]) => Promise<operations["getAllTokenIds"]["responses"]["200"]["content"]["application/json"]>;
    getContractNFTTransfers: (options: operations["getContractNFTTransfers"]["parameters"]["query"] & operations["getContractNFTTransfers"]["parameters"]["path"]) => Promise<operations["getContractNFTTransfers"]["responses"]["200"]["content"]["application/json"]>;
    getNftTransfersFromToBlock: (options: operations["getNftTransfersFromToBlock"]["parameters"]["query"] ) => Promise<operations["getNftTransfersFromToBlock"]["responses"]["200"]["content"]["application/json"]>;
    getNFTOwners: (options: operations["getNFTOwners"]["parameters"]["query"] & operations["getNFTOwners"]["parameters"]["path"]) => Promise<operations["getNFTOwners"]["responses"]["200"]["content"]["application/json"]>;
    getNFTMetadata: (options: operations["getNFTMetadata"]["parameters"]["query"] & operations["getNFTMetadata"]["parameters"]["path"]) => Promise<operations["getNFTMetadata"]["responses"]["200"]["content"]["application/json"]>;
    getTokenIdMetadata: (options: operations["getTokenIdMetadata"]["parameters"]["query"] & operations["getTokenIdMetadata"]["parameters"]["path"]) => Promise<operations["getTokenIdMetadata"]["responses"]["200"]["content"]["application/json"]>;
    getTokenIdOwners: (options: operations["getTokenIdOwners"]["parameters"]["query"] & operations["getTokenIdOwners"]["parameters"]["path"]) => Promise<operations["getTokenIdOwners"]["responses"]["200"]["content"]["application/json"]>;
    getWalletTokenIdTransfers: (options: operations["getWalletTokenIdTransfers"]["parameters"]["query"] & operations["getWalletTokenIdTransfers"]["parameters"]["path"]) => Promise<operations["getWalletTokenIdTransfers"]["responses"]["200"]["content"]["application/json"]>;
  }

  static resolve: {
    resolveDomain: (options: operations["resolveDomain"]["parameters"]["query"] & operations["resolveDomain"]["parameters"]["path"]) => Promise<operations["resolveDomain"]["responses"]["200"]["content"]["application/json"]>;
  }

  static defi: {
    getPairReserves: (options: operations["getPairReserves"]["parameters"]["query"] & operations["getPairReserves"]["parameters"]["path"]) => Promise<operations["getPairReserves"]["responses"]["200"]["content"]["application/json"]>;
    getPairAddress: (options: operations["getPairAddress"]["parameters"]["query"] & operations["getPairAddress"]["parameters"]["path"]) => Promise<operations["getPairAddress"]["responses"]["200"]["content"]["application/json"]>;
  }

  static storage: {
    uploadFolder: () => Promise<operations["uploadFolder"]["responses"]["200"]["content"]["application/json"]>;
  }

}
